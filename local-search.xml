<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java之HashMap源码及扩容机制</title>
    <link href="undefined2018/10/19/java_HashMap_learning/"/>
    <url>2018/10/19/java_HashMap_learning/</url>
    
    <content type="html"><![CDATA[<h3 id="HashMap源码及扩容机制"><a href="#HashMap源码及扩容机制" class="headerlink" title="HashMap源码及扩容机制"></a>HashMap源码及扩容机制</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为链表散列）。当新建一个hashmap的时候，就会初始化一个数组。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</code></pre><h4 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h4><p>HashMap的默认值必须规定时2的幂次，这样可以确保key算的index相同几率较小，查询效率较高。其中初始值为16，最大值为2的30次方，加载因子为0.75，还有与红黑树相关的三个参数。链表长度大于8时，转换为红黑树。<br>在static方法中重写了equals和hashcode方法</p><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable {    private static final long serialVersionUID = 362498820763181265L;    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    static final float DEFAULT_LOAD_FACTOR = 0.75f;    static final int TREEIFY_THRESHOLD = 8;    static final int MIN_TREEIFY_CAPACITY = 64;    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        }        public final K getKey()        { return key; }        public final V getValue()      { return value; }        public final String toString() { return key + &quot;=&quot; + value; }        public final int hashCode() {            return Objects.hashCode(key) ^ Objects.hashCode(value);        }        public final V setValue(V newValue) {            V oldValue = value;            value = newValue;            return oldValue;        }        public final boolean equals(Object o) {            if (o == this)                return true;            if (o instanceof Map.Entry) {                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                if (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    return true;            }            return false;        }    }    static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }    static Class&lt;?&gt; comparableClassFor(Object x) {        if (x instanceof Comparable) {            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;            if ((c = x.getClass()) == String.class) // bypass checks                return c;            if ((ts = c.getGenericInterfaces()) != null) {                for (int i = 0; i &lt; ts.length; ++i) {                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;                        ((p = (ParameterizedType)t).getRawType() ==                         Comparable.class) &amp;&amp;                        (as = p.getActualTypeArguments()) != null &amp;&amp;                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c                        return c;                }            }        }        return null;    }    /**     * Returns k.compareTo(x) if x matches kc (k&#39;s screened comparable     * class), else 0.     */    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {        return (x == null || x.getClass() != kc ? 0 :                ((Comparable)k).compareTo(x));    }    /**     * Returns a power of two size for the given target capacity.     */    static final int tableSizeFor(int cap) {        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }    /* ---------------- Fields -------------- */    /**     * The table, initialized on first use, and resized as     * necessary. When allocated, length is always a power of two.     * (We also tolerate length zero in some operations to allow     * bootstrapping mechanics that are currently not needed.)     */    transient Node&lt;K,V&gt;[] table;    /**     * Holds cached entrySet(). Note that AbstractMap fields are used     * for keySet() and values().     */    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    /**     * The number of key-value mappings contained in this map.     */    transient int size;    /**     * The number of times this HashMap has been structurally modified     * Structural modifications are those that change the number of mappings in     * the HashMap or otherwise modify its internal structure (e.g.,     * rehash).  This field is used to make iterators on Collection-views of     * the HashMap fail-fast.  (See ConcurrentModificationException).     */    transient int modCount;    /**     * The next size value at which to resize (capacity * load factor).     *     * @serial     */    // (The javadoc description is true upon serialization.    // Additionally, if the table array has not been allocated, this    // field holds the initial array capacity, or zero signifying    // DEFAULT_INITIAL_CAPACITY.)    int threshold;    /**     * The load factor for the hash table.     *     * @serial     */    final float loadFactor;    /* ---------------- Public operations -------------- */    /**     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial     * capacity and load factor.     *     * @param  initialCapacity the initial capacity     * @param  loadFactor      the load factor     * @throws IllegalArgumentException if the initial capacity is negative     *         or the load factor is nonpositive     */    public HashMap(int initialCapacity, float loadFactor) {        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    }    /**     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial     * capacity and the default load factor (0.75).     *     * @param  initialCapacity the initial capacity.     * @throws IllegalArgumentException if the initial capacity is negative.     */    public HashMap(int initialCapacity) {        this(initialCapacity, DEFAULT_LOAD_FACTOR);    }    /**     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity     * (16) and the default load factor (0.75).     */    public HashMap() {        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted    }    /**     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with     * default load factor (0.75) and an initial capacity sufficient to     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.     *     * @param   m the map whose mappings are to be placed in this map     * @throws  NullPointerException if the specified map is null     */    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    }</code></pre><h4 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h4><p>当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75</p><pre><code class="java">/*     put添加hash时，默认可以覆盖插入*/public V put(K key, V value) {        return putVal(hash(key), key, value, false, true);    }/*    newThr = oldThr &lt;&lt; 1*/final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else {            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    }                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                }            }            if (e != null) { // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            }        }        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    }    final Node&lt;K,V&gt;[] resize() {        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) {            if (oldCap &gt;= MAXIMUM_CAPACITY) {                threshold = Integer.MAX_VALUE;                return oldTab;            }            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; 1; // double threshold        }        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;        else {               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        if (newThr == 0) {            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold = newThr;        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;        if (oldTab != null) {            for (int j = 0; j &lt; oldCap; ++j) {                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) {                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash &amp; (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else { // preserve order                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;                        do {                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) {                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之ArrayList与LinkedList比较</title>
    <link href="undefined2018/10/17/java_ArrayList_learning/"/>
    <url>2018/10/17/java_ArrayList_learning/</url>
    
    <content type="html"><![CDATA[<h3 id="ArrayList与LinkedList比较"><a href="#ArrayList与LinkedList比较" class="headerlink" title="ArrayList与LinkedList比较"></a>ArrayList与LinkedList比较</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>ArrayListArrayList的底层实现为数组存储在内存中，线程不同步。可通过数组下标的形式进行查找，所以在查询方面的效率较为出色，常用在查询较多的情景下。LinkedListLinkedList的底层实现为链表形式，也为线程不同步。而链表的底层也决定了它在查询方面不如数组底层的ArrayList而在指定位置插入等修改操作下，性能优于ArrayList。Vector另外还有Vector，Vector也是和ArrayList、LinkedList一样实现了java.util.List接口。最大的区别在于Vestor是线程同步的，所以在效率方面不如另外两者，适用于多线程项目中。</code></pre><h4 id="LinkedList扩容"><a href="#LinkedList扩容" class="headerlink" title="LinkedList扩容"></a>LinkedList扩容</h4><pre><code>由于它的底层是用双向链表实现的，没有初始化大小，也没有扩容的机制。每次add操作只需要将last的链表和新的添加连起来合成新的就可以了</code></pre><pre><code class="java"> public boolean add(E e) {        linkLast(e);        return true;    }  void linkLast(E e) {        final Node&lt;E&gt; l = last;        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);        last = newNode;        if (l == null)            first = newNode;        else            l.next = newNode;        size++;        modCount++;    }</code></pre><h4 id="ArrayList初始化"><a href="#ArrayList初始化" class="headerlink" title="ArrayList初始化"></a>ArrayList初始化</h4><p>ArrayList继承自AbstractList，实现了 List<e>, RandomAccess, Cloneable, java.io.Serializable接口，因此可以copy和序列化<br>这里可以看到定义了ArrayList的默认初始值的10，最大值是2的31次方-8。<br>有三个构造函数，分别是一个无参构造函数和两个有参构造函数，</e></p><pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    private static final long serialVersionUID = 8683452581122892189L;    /**     * Default initial capacity.     */    private static final int DEFAULT_CAPACITY = 10;    /*     这里定义了arrayList的最大值，2的31次方-8;    */     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    /**     * Shared empty array instance used for empty instances.     */    private static final Object[] EMPTY_ELEMENTDATA = {};    /**     * Shared empty array instance used for default sized empty instances. We     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when     * first element is added.     */    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};    /**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the length of this array buffer. Any     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * will be expanded to DEFAULT_CAPACITY when the first element is added.     */    transient Object[] elementData; // non-private to simplify nested class access    private int size;    public ArrayList(int initialCapacity) {        if (initialCapacity &gt; 0) {            this.elementData = new Object[initialCapacity];        } else if (initialCapacity == 0) {            this.elementData = EMPTY_ELEMENTDATA;        } else {            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        }    }    /**     * Constructs an empty list with an initial capacity of ten.     */    public ArrayList() {        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    }    public ArrayList(Collection&lt;? extends E&gt; c) {        elementData = c.toArray();        if ((size = elementData.length) != 0) {            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        } else {            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        }    }</code></pre><h4 id="ArrayList扩容"><a href="#ArrayList扩容" class="headerlink" title="ArrayList扩容"></a>ArrayList扩容</h4><p>扩容操作在执行add操作时执行，可以看出add操作制作两件事。<br>    - 1.执行所需容量加1<br>    - 2.执行将添加元素加入列表<br>在ensureCapacityInternal会将新的所需容量传递给calculateCapacity，它会判断，如果elementData为空时，直接返回默认初始值10，否则返回所需容量值，<br>ensureExplicitCapacity则会执行modCount加1的操作，用于记录每次add操作，然后判断所需容量大于当前数组长度后，执行grow进行扩容，每次扩容的量时现有容量的1.5倍</p><pre><code class="java">/*在执行add添加新元素时，首先执行ensureCapacityInternal，使最小容量加1，然后将添加的元素存入索引为size++的elementData中，返回true*/public boolean add(E e) {        ensureCapacityInternal(size + 1);  // Increments modCount!!        elementData[size++] = e;        return true;    }private void ensureCapacityInternal(int minCapacity) {        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));    }/*    calculateCapacity判断elementData不等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA时（即不是空时），返回minCapacity，否则直接返回默认值10*/private static int calculateCapacity(Object[] elementData, int minCapacity) {        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {            return Math.max(DEFAULT_CAPACITY, minCapacity);        }        return minCapacity;    }/*    继承自abstractList的modCount++，记录每次执行add的次数，当minCapacity大于elementData.length时，执行扩容*/private void ensureExplicitCapacity(int minCapacity) {        modCount++;        // overflow-conscious code        if (minCapacity - elementData.length &gt; 0)            grow(minCapacity);    }    /**     * 这里执行真正的扩容操作，新容量=旧容量+旧容量/2，       如果新容量依然小于所需容量，新容量=所需容量，       如果新容量大于最大容量，返回最大容量，确保容量不能超过最大容量       然后将数据copy到新的大容量list中     *     * @param minCapacity 所需要的最小容量     */    private void grow(int minCapacity) {        // overflow-conscious code        int oldCapacity = elementData.length;        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);        if (newCapacity - minCapacity &lt; 0)            newCapacity = minCapacity;        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)            newCapacity = hugeCapacity(minCapacity);        // minCapacity is usually close to size, so this is a win:        elementData = Arrays.copyOf(elementData, newCapacity);    }    private static int hugeCapacity(int minCapacity) {        if (minCapacity &lt; 0) // overflow            throw new OutOfMemoryError();        return (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grafna influxdb 监控服务</title>
    <link href="undefined2018/05/01/influxdb_granfa/"/>
    <url>2018/05/01/influxdb_granfa/</url>
    
    <content type="html"><![CDATA[<h2 id="python-influxdb-grafana监控系统"><a href="#python-influxdb-grafana监控系统" class="headerlink" title="python+influxdb+grafana监控系统"></a>python+influxdb+grafana监控系统</h2><p>Tips：<br>    python收集数据，起udp client发送消息<br>    python 起udp server接收数据，定时刷新通过graphite协议将数据发送到influxDB<br>    grafana来展示influxDB的数据</p><h4 id="安装influxdb"><a href="#安装influxdb" class="headerlink" title="安装influxdb"></a>安装influxdb</h4><pre><code>curl -sL https://repos.influxdata.com/influxdb.key | sudo apt-key add -echo &quot;deb https://repos.influxdata.com/ubuntu trusty stable&quot; | sudo tee /etc/apt/sources.list.d/influxdb.listapt updateapt install influxdbsudo service influxdb start</code></pre><h4 id="配置influxdb"><a href="#配置influxdb" class="headerlink" title="配置influxdb"></a>配置influxdb</h4><p>详细配置参数信息参考官网<a href="https://docs.influxdata.com/influxdb/v1.7/administration/config/" target="_blank" rel="noopener">https://docs.influxdata.com/influxdb/v1.7/administration/config/</a><br>这里主要开启graphite的配置，用于接收监控客户端传来的数据，其他配置默认</p><pre><code>[[graphite]]  # Determines whether the graphite endpoint is enabled.  enabled = true  database = &quot;grafana&quot;  retention-policy = &quot;&quot;  bind-address = &quot;:2003&quot;  protocol = &quot;tcp&quot;  consistency-level = &quot;one&quot;  templates = [    &quot;.host.measurement*&quot;,    # Default template    # &quot;server.*&quot;,  ]  # templates参数可以将.host.measurement*之前的配置变成tag插入表中，在grafana中可以用作tag筛选</code></pre><h4 id="安装grafana"><a href="#安装grafana" class="headerlink" title="安装grafana"></a>安装grafana</h4><p>详细参照grafana官网<a href="http://docs.grafana.org/installation/debian/" target="_blank" rel="noopener">http://docs.grafana.org/installation/debian/</a></p><pre><code>curl https://packages.grafana.com/gpg.key | sudo apt-key add -Update your Apt repositories and install Grafanasudo apt-get updatesudo apt-get install grafanaOn some older versions of Ubuntu and Debian you may need to install the apt-transport-https package which is needed to fetch packages over HTTPS.sudo apt-get install -y apt-transport-httpssudo service grafana-server start</code></pre><h4 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h4><p>将data sources配置成上面的influxdb的地址</p><h4 id="python向influxdb发送数据"><a href="#python向influxdb发送数据" class="headerlink" title="python向influxdb发送数据"></a>python向influxdb发送数据</h4><p>开启graphite协议，接收的数据格式如下：</p><p>“metric_path value timestamp\n”</p><p><code>metric_path</code>: arbitrary namespace containing substrings delimited by dots. The most general name is at the left and the most specific is at the right.<br><code>value</code>: numeric value to store.<br><code>timestamp</code>: epoch time.<br>messages must end with a trailing newline.<br>multiple messages maybe be batched and sent in a single socket operation. each message is delimited by a newline, with a trailing newline at the end of the message batch.</p><p>Example message:</p><p><code>&quot;foo.bar.baz 42 74857843\n&quot;</code></p><p>Let’s look at some (Python 2.7) code for sending data to graphite…</p><pre><code>#!/usr/bin/env pythonimport platformimport socketimport time_SERVER = &#39;0.0.0.0&#39;_PORT = 2003DELAY = 15  # secsdef get_loadavgs():    with open(&#39;/proc/loadavg&#39;) as f:        return f.read().strip().split()[:3]def send_msg(message):    print &#39;sending message:\n%s&#39; % message    sock = socket.socket()    sock.connect((_SERVER, _PORT))    sock.sendall(message)    sock.close()if __name__ == &#39;__main__&#39;:    node = platform.node().replace(&#39;.&#39;, &#39;-&#39;)    while True:        timestamp = int(time.time())        loadavgs = get_loadavgs()        lines = [            &#39;system.%s.loadavg_1min %s %d&#39; % (node, loadavgs[0], timestamp),            &#39;system.%s.loadavg_5min %s %d&#39; % (node, loadavgs[1], timestamp),            &#39;system.%s.loadavg_15min %s %d&#39; % (node, loadavgs[2], timestamp)        ]        message = &#39;\n&#39;.join(lines) + &#39;\n&#39;        send_msg(message)        time.sleep(DELAY)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>influxdb监控之statsclient端介绍</title>
    <link href="undefined2018/02/01/statsclient_learning/"/>
    <url>2018/02/01/statsclient_learning/</url>
    
    <content type="html"><![CDATA[<h1 id="statsclient"><a href="#statsclient" class="headerlink" title="statsclient"></a>statsclient</h1><pre><code>statsclient 是 statsd 系统的客户端。关于 statsd 的介绍参考: https://www.jianshu.com/p/f6f18cc268a4,stats(client + server) + influxdb + grafana, 其中 statsclient 和 statsserver是自己用python写的。statsclient 会把数据传给 statsserver,statsserver 通过汇总等处理将数据存储到 influxdb, grafana 从 influxdb 获取数据进行可视化展示并提供报警功能。这里我们只介绍 statsclient 的使用。</code></pre><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>建立实例</p><pre><code class="python">from gogo.common.statsclient import StatsClient# 默认stats_client = StatsClient()# 指定主机名和端口stats_client = StatsClient(host=&#39;192.168.8.1&#39;, port=8125)# 指定前缀stats_client = StatsClient(prefix=&#39;your_prefix&#39;)</code></pre><h4 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h4><pre><code class="python">stats_client.incr(&#39;count_metric&#39;)  # 1stats_client.incr(&#39;count_metric&#39;, 10)  # 1 + 10 = 11stats_client.incr(&#39;count_metric&#39;)  # 11 + 1 = 12stats_client.decr(&#39;count_metric&#39;)  # 12 - 1 = 11</code></pre><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><pre><code class="python">stats_client.timing(&#39;time_metric&#39;, 10)# with 块儿中代码的执行时间会被记录到 time_metric 指标上with stats_client.timer(&#39;time_metric&#39;):    # do something</code></pre><h4 id="Gauge"><a href="#Gauge" class="headerlink" title="Gauge"></a>Gauge</h4><pre><code class="python">stats_client.gauge(&#39;gauge_metric&#39;, 10)stats_client.gauge(&#39;gauge_metric&#39;, -5)</code></pre><h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><pre><code class="python"># pipeline 里的指标会被批量发送with stats_client.pipeline() as pipeline:    pipeline.incr(&#39;count_metric&#39;)    pipeline.decr(&#39;count_metric&#39;)    pipeline.timing(&#39;time_metric&#39;)    pipeline.gauge(&#39;gauge_metric&#39;)    with pipeline.timer(&#39;time_metric&#39;):        # do something</code></pre><h2 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h2><h2 id="StatsClient"><a href="#StatsClient" class="headerlink" title="StatsClient"></a>StatsClient</h2><pre><code class="python">class gogo.common.statsclient.StatsClient(    host=&#39;127.0.0.1&#39;,    port=8125,    prefix=None)</code></pre><ul><li>host 和 port: stats server 的主机地址。stats client 会把数据发送到这个地址。</li><li>prefix: 指标前缀, 如果不为 None, 所有指标的前面都会加上 ‘prefix.’。</li></ul><pre><code class="python">stats_client = StatsClient(prefix=&#39;mertic_prefix&#39;)stats_client.incr(&#39;a.b&#39;)  # 实际的指标名称是 metric_prefix.a.b</code></pre><p><strong>incr</strong>(stat, count=1, rate=1)</p><ul><li>rate: 采样率。如果小于 1, 发送的数据会按这个比例进行采样。</li></ul><pre><code class="python">stats_client = StatsClient()stats_client.incr(&#39;a.b&#39;, rate=0.5)  # 以 0.5 的比例采样</code></pre><p><strong>decr</strong>(stat, count=1, rate=1)</p><p><strong>gauge</strong>(stat, value, rate=1, delta=False)</p><ul><li>delta: True 表示累加模式, False 表示替换模式。</li></ul><pre><code class="python">stats_client = StatsClient()stats_client.gauge(&#39;a.b&#39;, 10)  # 10stats_client.gauge(&#39;a.b&#39;, 11)  # 11stats_client.gauge(&#39;c.d&#39;, 10, delta=True)  # 10stats_client.gauge(&#39;c.d&#39;, 11, delta=True)  # 10 + 11 = 21</code></pre><p><strong>timing</strong>(stat, delta, rate=1)</p><p><strong>pipeline</strong>()</p><p><strong>timer</strong>(stat, rate=1)</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh 隧道及代理转发</title>
    <link href="undefined2017/12/01/ssh_tunnel/"/>
    <url>2017/12/01/ssh_tunnel/</url>
    
    <content type="html"><![CDATA[<h1 id="ssh-tunnel"><a href="#ssh-tunnel" class="headerlink" title="ssh tunnel"></a>ssh tunnel</h1><h3 id="VPN-vs-SSH"><a href="#VPN-vs-SSH" class="headerlink" title="VPN vs SSH"></a>VPN vs SSH</h3><p>VPN和SSH隧道翻墙有如下区别：</p><p>VPN的设置是全局的，即电脑一旦挂上VPN，所有的联网程序都将自动使用VPN；而建立好SSH隧道后，需要程序设定使用隧道才会使用隧道联网<br>如果使用商用的VPN一般要花钱，如果自己搭，VPN的搭建难度大于SSH隧道。因为SSH隧道只要一台可以SSH的服务器即可，根本不需要在服务器上配置任何东西</p><h3 id="ssh动态绑定"><a href="#ssh动态绑定" class="headerlink" title="ssh动态绑定"></a>ssh动态绑定</h3><p>首先，墙内的客户机跟墙外的代理服务器，建立好SSH连接，并设定动态绑定<br>此时墙内客户机上的SSH会监听本地的一个端口7001<br>客户机上的程序，将对<a href="http://www.youtube.com:80的请求告知7001端口的SSH，SSH将此请求通过SSH加密连接发送到墙外服务器的SSH上" target="_blank" rel="noopener">www.youtube.com:80的请求告知7001端口的SSH，SSH将此请求通过SSH加密连接发送到墙外服务器的SSH上</a><br>由于建立的动态绑定，服务器会将<a href="http://www.youtube.com:80的请求发送给www.youtube.com上的80端口，并在收到回复后，通过原路返回给客户机的SSH，客户机的SSH返回给应用程序" target="_blank" rel="noopener">www.youtube.com:80的请求发送给www.youtube.com上的80端口，并在收到回复后，通过原路返回给客户机的SSH，客户机的SSH返回给应用程序</a></p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>1.在本地执行</p><pre><code> ssh -fND localhost:8888 root@remote_ip # 透過 ssh 建立一個 socks5 通過代理上網</code></pre><p>2.配置fiewfox</p><pre><code>firefox -&gt; ... -&gt; 手動設定 proxy 將 socks 主機 設成 localhost, port 設定成 8888</code></pre><p>3.验证</p><p>使用firefox，访问whatisip，查看现在的ip已经是remote_ip，就说明已经成功</p><p>$ man ssh</p><ul><li><p>-N 不執行任何指令 (只連接主機　不打開 shell)</p></li><li><p>-f 在背景執行</p></li><li><p>-D 建 socks5 的 proxy</p></li></ul><h1 id="ssh-代理转发"><a href="#ssh-代理转发" class="headerlink" title="ssh 代理转发"></a>ssh 代理转发</h1><p>Ssh-agent 可以帮助ssh转发秘钥，实现代理转发，将所有key配置在本地机器，即可实现线上主机之间的无密码登陆操作。</p><p>原理：<br>    目标机器：A<br>    目标机器：B<br>    本地机器：C<br>    本地代理：D</p><pre><code>在本地C上配置目标机器A和B的key，实现本地机器可以免密访问A，B，现在需要在A上执行ansible命令，免密操作B，正常情况需要在A上面配置访问B的key，然后实现免密操作，现在为了避免在A上存储key，使用ssh-agent代理，即D。使得C向B询问key时，通过代理D进行验证，只需要本地配置有key即可。</code></pre><p>配置：<br>    本地C：<br>        打开文件~/.ssh/config</p><pre><code>Host AHostName 34.196.105.41IdentityFile ~/.ssh/A.pemUser ubuntuForwardAgent yesHost BHostName 34.196.105.41IdentityFile ~/.ssh/B.pemUser ubuntuForwardAgent yes</code></pre><p>使用ssh-add -K A.pem<br>       Ssh-add -K B.pem<br>添加操作服务器的秘钥到代理</p><pre><code>确保sshd_config: 代理转发也可能在您的服务器上被阻止。您可以检查代理转发是否允许通过SSH进入服务器并正在运行sshd_config。此命令的输出应指示AllowAgentForwarding已设置。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flask request 上下文源码解读</title>
    <link href="undefined2017/12/01/flask_source_request_context/"/>
    <url>2017/12/01/flask_source_request_context/</url>
    
    <content type="html"><![CDATA[<h2 id="flask上下文"><a href="#flask上下文" class="headerlink" title="flask上下文"></a>flask上下文</h2><pre><code>涉及三个类，    1.存储东西的类 2.中介处理的类 3.真正处理的类</code></pre><pre><code>1. app.run()2. run_simple(host, port, self, **options)3. def __call__(self, environ, start_response):        &quot;&quot;&quot;The WSGI server calls the Flask application object as the        WSGI application. This calls :meth:`wsgi_app` which can be        wrapped to applying middleware.&quot;&quot;&quot;        return self.wsgi_app(environ, start_response)4. def wsgi_app(self, environ, start_response):        ctx = self.request_context(environ)        error = None        try:            try:                ctx.push()                response = self.full_dispatch_request()            except Exception as e:                error = e                response = self.handle_exception(e)            except:                error = sys.exc_info()[1]                raise            return response(environ, start_response)        finally:            if self.should_ignore_error(error):                error = None            ctx.auto_pop(error)</code></pre><p>#################################<br>ctx = self.request_context(environ)</p><p>######将请求相关的东西给ctx</p><pre><code>1. def request_context(self, environ):        &quot;&quot;&quot;Create a :class:`~flask.ctx.RequestContext` representing a        WSGI environment. Use a ``with`` block to push the context,        which will make :data:`request` point at this request.        See :doc:`/reqcontext`.        Typically you should not call this from your own code. A request        context is automatically pushed by the :meth:`wsgi_app` when        handling a request. Use :meth:`test_request_context` to create        an environment and context instead of this method.        :param environ: a WSGI environment        &quot;&quot;&quot;        return RequestContext(self, environ)2. RequestContext  __init__()3. app.request_class(environ)4. request_class = Request</code></pre><p>################################</p><p>###############################<br>ctx.push()</p><p>###########将ctx加入的字典</p><h3 id="请求相关所有数据存入-request-ctx-stack"><a href="#请求相关所有数据存入-request-ctx-stack" class="headerlink" title="请求相关所有数据存入_request_ctx_stack"></a>请求相关所有数据存入_request_ctx_stack</h3><pre><code>1._request_ctx_stack.push(self)  2._request_ctx_stack = LocalStack()  3.LocalStack(）__init__()  4.self._local = Local()  5.LocalStack().push()  6.self._local.stack = rv = []  7.def __setattr__(self, name, value):          ident = self.__ident_func__()          storage = self.__storage__          try:              storage[ident][name] = value          except KeyError:              storage[ident] = {name: value}  8.rv.append(ctx)  </code></pre><p>###########################<br>ctx.auto_pop(error)</p><p>##########<br>1._request_ctx_stack.pop(self)</p><h4 id="总结上下文管理机制"><a href="#总结上下文管理机制" class="headerlink" title="总结上下文管理机制"></a>总结上下文管理机制</h4><pre><code>  1.threading.Local和flask的local，增加了greenlet的携程判断    2.Local对象保存request值    3.请求进来封装了两层 request_context里有request和session    4.通过localstack将信息加到local    5.localproxy是一个偏函数  </code></pre><p>请求到来：</p><ul><li>ctx = 封装RequestContext(request,session)</li><li>ctx放入local中<br>执行视图函数</li><li>导入request</li><li>print(request) – localproxy对象的<strong>str</strong><br>  调用_lookup_req_object函数，去local中将RequestContext获取，再去RequestContext获取request<br>请求结束</li><li>ctx.auto_pop()</li><li>ctx从local中移除</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cut awk sed 用法总结</title>
    <link href="undefined2017/12/01/three_bitch/"/>
    <url>2017/12/01/three_bitch/</url>
    
    <content type="html"><![CDATA[<h2 id="awk-sed-cut-grep"><a href="#awk-sed-cut-grep" class="headerlink" title="awk sed cut grep"></a>awk sed cut grep</h2><h4 id="cut-learning"><a href="#cut-learning" class="headerlink" title="cut learning"></a>cut learning</h4><p>cut以某种方式按照文件的行进行分割</p><p>cut参数：</p><ul><li>-b 按照字节选取</li><li>-c 按照字符选取</li><li>-d 自定义分隔符，默认为制表符</li><li>-f 与-d一起使用，指定显示的区域</li></ul><p>example：</p><pre><code>cat /etc/passwd | cut -b1-3 #取每行的第1-3字字节cat /etc/passwd | cut -b1-3,4-5,5-8 #获取每行的第1-3 4-5 5-8字节cat /etc/passwd | cut -d &quot;:&quot; -f 3 #以&quot;:&quot;分割取第三段cat /etc/passwd | cut -d &quot; &quot; -f 3 #以&quot; &quot;分割取第三段</code></pre><h4 id="awk-learning"><a href="#awk-learning" class="headerlink" title="awk learning"></a>awk learning</h4><pre><code>awk [options] [program] [file]awk -F &quot;:&quot; &#39;{print $1}&#39; file   #按照&quot;:&quot;将每行分割后，取每行的第一个字段，$0表示整行内容，$1表示1行，以此类推awk  &#39;{$1=&quot;123&quot;;print $0}&#39; test #按照空格将每行分割，将每行第一个字段替换成123，并打印出整行内容awk &#39;NR==2&#39; file        #输出awk执行文件后所读取的数据行数为2的那一行sort learningsort -u  排序并且排除重复项sort -r  反向排序sort -f  忽略大小写</code></pre><p>1.获取主机ip</p><p>init content：</p><pre><code>[root@node1 log]# ifconfigdocker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        inet 172.33.86.1  netmask 255.255.255.0  broadcast 0.0.0.0        ether 02:42:d3:b2:43:cf  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255        inet6 fe80::5054:ff:fead:3b43  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 52:54:00:ad:3b:43  txqueuelen 1000  (Ethernet)        RX packets 3713  bytes 323953 (316.3 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 2249  bytes 281163 (274.5 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>solution:</p><p><code>ifconfig eth0 |awk &#39;{ print $2 }&#39; | sed -n &#39;2p&#39;</code><br><code>ifconfig eth0 | awk &#39;NR==2&#39; |awk &#39;{print $2}&#39;</code></p><p>2.查看http并发请求数与tcp连接状态</p><p><code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for (a in S) print a,S[a]}&#39;</code><br><code>netstat -n | awk &#39;/^tcp/{print $NF}&#39; | sort | uniq -c</code><br>uniq -c 在每列旁显示该行重复出现的次数</p><p>3.获取nginx的log访问数量前10的ip</p><p><code>cat access.log |grep awk {print $1} | sort -rn | uniq -c | head -10</code></p><p>tip:<br>1.cut的功能是分割每行的内容，这个awk几乎可以代替<br>2.awk的功能就是分割每行内容，也可以使用NR或者FNR来取到具体某一行的内容，功能比较全<br>3.sed也可以取到某一行的数据，同时也可以使用正则匹配具体内容  </p>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之jedis操作redis</title>
    <link href="undefined2017/10/02/java_jedis_learning/"/>
    <url>2017/10/02/java_jedis_learning/</url>
    
    <content type="html"><![CDATA[<h3 id="java之jedis操作redis"><a href="#java之jedis操作redis" class="headerlink" title="java之jedis操作redis"></a>java之jedis操作redis</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><pre><code>jedis客户端操作redis主要三种模式：单台模式、分片模式（ShardedJedis）、集群模式（BinaryJedisCluster） ShardedJedis是通过一致性哈希来实现分布式缓存的，通过一定的策略把不同的key分配到不同的redis server上，达到横向扩展的目的。这里主要介绍使用ShardedJedisPool+ShardedJedis操作redis的方式</code></pre><h4 id="操作redis数据demo"><a href="#操作redis数据demo" class="headerlink" title="操作redis数据demo"></a>操作redis数据demo</h4><pre><code>package com.redis.demo;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.JedisShardInfo;import redis.clients.jedis.ShardedJedis;import redis.clients.jedis.ShardedJedisPool;import java.util.ArrayList;import java.util.List;public class demo {    static JedisPoolConfig config;    static ShardedJedisPool sharedJedisPool;    static {        // 生成多机连接List        List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;();        shards.add( new JedisShardInfo(&quot;192.168.17.131&quot;, 6379) );        shards.add( new JedisShardInfo(&quot;192.168.17.130&quot;, 6379) );        // 初始化连接池配置对象        config = new JedisPoolConfig();        config.setMaxIdle(10);        // 实例化连接池        sharedJedisPool = new ShardedJedisPool(config,shards);    }    public static void main(String[] args) {        // 从连接池获取Jedis连接        ShardedJedis shardedJedisConn = sharedJedisPool.getResource();        shardedJedisConn.set(&quot;happy&quot;, &quot;sunny&quot;);        System.out.println(shardedJedisConn.get(&quot;happy&quot;));        // 释放连接        close(shardedJedisConn, sharedJedisPool);    }    private static void close(ShardedJedis shardedJedis,ShardedJedisPool sharedJedisPool){        if(shardedJedis!=null &amp;&amp;sharedJedisPool!=null){            sharedJedisPool.returnResource(shardedJedis);        }        if(sharedJedisPool!=null){            sharedJedisPool.destroy();        }    }}</code></pre><h4 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h4><h6 id="1-连接操作命令"><a href="#1-连接操作命令" class="headerlink" title="1 连接操作命令"></a>1 连接操作命令</h6><ul><li>quit：关闭连接（connection）</li><li>auth：简单密码认证</li><li>help cmd： 查看cmd帮助，例如：help quit</li></ul><h6 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2 持久化"></a>2 持久化</h6><ul><li>save：将数据同步保存到磁盘</li><li>bgsave：将数据异步保存到磁盘</li><li>lastsave：返回上次成功将数据保存到磁盘的Unix时戳</li><li>shutdown：将数据同步保存到磁盘，然后关闭服务</li></ul><h6 id="3-远程服务控制"><a href="#3-远程服务控制" class="headerlink" title="3 远程服务控制"></a>3 远程服务控制</h6><ul><li>info：提供服务器的信息和统计</li><li>monitor：实时转储收到的请求</li><li>slaveof：改变复制策略设置</li><li>config：在运行时配置Redis服务器</li></ul><h6 id="4-对key操作的命令"><a href="#4-对key操作的命令" class="headerlink" title="4 对key操作的命令"></a>4 对key操作的命令</h6><ul><li>exists(key)：确认一个key是否存在</li><li>del(key)：删除一个key</li><li>type(key)：返回值的类型</li><li>keys(pattern)：返回满足给定pattern的所有key</li><li>randomkey：随机返回key空间的一个</li><li>keyrename(oldname, newname)：重命名key</li><li>dbsize：返回当前数据库中key的数目</li><li>expire：设定一个key的活动时间（s）</li><li>ttl：获得一个key的活动时间</li><li>select(index)：按索引查询</li><li>move(key, dbindex)：移动当前数据库中的key到dbindex数据库</li><li>flushdb：删除当前选择数据库中的所有key</li><li>flushall：删除所有数据库中的所有key</li></ul><h6 id="5-String"><a href="#5-String" class="headerlink" title="5 String"></a>5 String</h6><ul><li>set(key, value)：给数据库中名称为key的string赋予值value</li><li>get(key)：返回数据库中名称为key的string的value</li><li>getset(key, value)：给名称为key的string赋予上一次的value</li><li>mget(key1, key2,…, key N)：返回库中多个string的value</li><li>setnx(key, value)：添加string，名称为key，值为value</li><li>setex(key, time, value)：向库中添加string，设定过期时间time</li><li>mset(key N, value N)：批量设置多个string的值</li><li>msetnx(key N, value N)：如果所有名称为key i的string都不存在</li><li>incr(key)：名称为key的string增1操作</li><li>incrby(key, integer)：名称为key的string增加integer</li><li>decr(key)：名称为key的string减1操作</li><li>decrby(key, integer)：名称为key的string减少integer</li><li>append(key, value)：名称为key的string的值附加value</li><li>substr(key, start, end)：返回名称为key的string的value的子串</li></ul><h6 id="6-List"><a href="#6-List" class="headerlink" title="6 List"></a>6 List</h6><ul><li>rpush(key, value)：在名称为key的list尾添加一个值为value的元素</li><li>lpush(key, value)：在名称为key的list头添加一个值为value的 元素</li><li>llen(key)：返回名称为key的list的长度</li><li>lrange(key, start, end)：返回名称为key的list中start至end之间的元素</li><li>ltrim(key, start, end)：截取名称为key的list</li><li>lindex(key, index)：返回名称为key的list中index位置的元素</li><li>lset(key, index, value)：给名称为key的list中index位置的元素赋值</li><li>lrem(key, count, value)：删除count个key的list中值为value的元素</li><li>lpop(key)：返回并删除名称为key的list中的首元素</li><li>rpop(key)：返回并删除名称为key的list中的尾元素</li><li>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。</li><li>brpop(key1, key2,… key N, timeout)：rpop的block版本。</li><li>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</li></ul><h6 id="7-Set"><a href="#7-Set" class="headerlink" title="7 Set"></a>7 Set</h6><ul><li>sadd(key, member)：向名称为key的set中添加元素member</li><li>srem(key, member) ：删除名称为key的set中的元素member</li><li>spop(key) ：随机返回并删除名称为key的set中一个元素</li><li>smove(srckey, dstkey, member) ：移到集合元素</li><li>scard(key) ：返回名称为key的set的基数</li><li>sismember(key, member) ：member是否是名称为key的set的元素</li><li>sinter(key1, key2,…key N) ：求交集</li><li>sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合</li><li>sunion(key1, (keys)) ：求并集</li><li>sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合</li><li>sdiff(key1, (keys)) ：求差集</li><li>sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合</li><li>smembers(key) ：返回名称为key的set的所有元素</li><li>srandmember(key) ：随机返回名称为key的set的一个元素</li></ul><h6 id="8-Hash"><a href="#8-Hash" class="headerlink" title="8 Hash"></a>8 Hash</h6><ul><li>hset(key, field, value)：向名称为key的hash中添加元素field</li><li>hget(key, field)：返回名称为key的hash中field对应的value</li><li>hmget(key, (fields))：返回名称为key的hash中field i对应的value</li><li>hmset(key, (fields))：向名称为key的hash中添加元素field</li><li>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer</li><li>hexists(key, field)：名称为key的hash中是否存在键为field的域</li><li>hdel(key, field)：删除名称为key的hash中键为field的域</li><li>hlen(key)：返回名称为key的hash中元素个数</li><li>hkeys(key)：返回名称为key的hash中所有键</li><li>hvals(key)：返回名称为key的hash中所有键对应的value</li><li>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</li></ul><pre><code></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之代理模式</title>
    <link href="undefined2017/10/01/java_AOP_learning/"/>
    <url>2017/10/01/java_AOP_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="java之代理模式"><a href="#java之代理模式" class="headerlink" title="java之代理模式"></a>java之代理模式</h2><ul><li><ol><li>静态代理  </li></ol></li><li><ol start="2"><li>动态代理  </li></ol></li><li><ol start="3"><li>spring aop思考  </li></ol></li></ul><h3 id="环境沉浸"><a href="#环境沉浸" class="headerlink" title="环境沉浸"></a>环境沉浸</h3><pre><code>1. 现在我有两个服务，分别是朋友圈评论功能和朋友圈点赞功能，想要不改变原有代码的基础上，实现功能前登录以及功能后输出日志的需求2. 这是朋友圈评论的功能Comment接口类```package com.dynamoProxy;public interface Comment {    //添加评论的方法    void add(String msg,String user);    //删除评论方法    void delete(String msgId);}```Comment接口实现类```    package com.dynamoProxy;    public class CommentImpl implements Comment {        @Override        public void add(String msg, String user) {            System.out.println(&quot;我要给&quot;+user+&quot;添加一条评论:&quot;+msg);        }        @Override        public void delete(String msgId) {            System.out.println(&quot;我删除了&quot;+msgId+&quot;这条评论&quot;);        }    }```</code></pre><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><pre><code>使用CommentProxy实现Comment类，构造器中接收实现Comment的任意对象，并赋值给this.comment，在add方法前后添加登录和日志记录方法，基本实现了需求Comment静态代理类        </code></pre><pre><code>    package com.dynamoProxy;    public class CommentProxy implements Comment {        private Comment comment;        public CommentProxy(Comment comment){            this.comment = comment;        }        @Override        public void add(String msg, String user) {            precomment();            comment.add(msg,user);            endcomment();        }        @Override        public void delete(String msgId) {            comment.delete(msgId);            endcomment();        }        private void precomment(){            System.out.println(&quot;实现登录模块&quot;);        }        private void endcomment(){            System.out.println(&quot;输出日志&quot;);        }    }</code></pre><pre><code>Comment静态代理测试类```    package com.dynamoProxy;</code></pre><p>public class testDemo {<br>    public static void main(String[] args) {</p><pre><code>   CommentProxy commentProxy = new CommentProxy(new CommentImpl());   commentProxy.add(&quot;这首说好不哭真好听&quot;,&quot;周杰伦&quot;);   commentProxy.delete(&quot;11012&quot;);}</code></pre><p>}</p><pre><code>```</code></pre><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><pre><code>上面的静态代理满足需求后，我们希望给点赞功能也实现登录和日志的代理，但是此时需要再次写一个PariseProxy的类，继承Parise的接口，并接收Parise的对象。如果我们由很多功能的话，这会造成一定的代码冗余，因此，动态代理走上舞台,我们需要通过反射来让代理类自己获取要代理的类以及该类的方法，这里需要实现InvocationHandler接口</code></pre><pre><code>    package com.dynamoProxy;    import java.lang.reflect.InvocationHandler;    import java.lang.reflect.Method;    import java.lang.reflect.Proxy;    public class DynamCommentProxy implements InvocationHandler {        private Object target;        public  Object bind(Object object){            this.target = object;            return Proxy.newProxyInstance(this.target.getClass().getClassLoader(),this.target.getClass().getInterfaces(),this);        }        @Override        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            Object result = null;            precomment();            method.invoke(this.target,args);            endcomment();            return result;        }        private void precomment(){            System.out.println(&quot;// something you want to do before comment&quot;);        }        private void endcomment(){            System.out.println(&quot;// something you want to do before comment&quot;);        }    }</code></pre><p>动态代理测试类</p><pre><code>    package com.dynamoProxy;public class testDemo {    public static void main(String[] args) {        DynamCommentProxy dynamCommentProxy = new DynamCommentProxy();        Comment comment = (Comment) dynamCommentProxy.bind(new CommentImpl());        comment.delete(&quot;111&quot;);        Parise parise = (Parise)  dynamCommentProxy.bind(new PariseImpl());        parise.up();    }}</code></pre><h4 id="spring-AOP"><a href="#spring-AOP" class="headerlink" title="spring AOP"></a>spring AOP</h4><pre><code>上面的动态代理实现了，可以代理不同的服务，实现登录和日志，但是登录和日志写死在了动态代理的类中，我们是否可以将其解耦，不仅让代理对象可以改变，让代理功能也可以改变- 实现代理功能```package com.dynamoProxy;public interface Login {    void preLogin();    void endLogin();}``````package com.dynamoProxy;public class LoginImpl implements Login {    @Override    public void preLogin() {        System.out.println(&quot;login开始&quot;);    }    @Override    public void endLogin() {        System.out.println(&quot;login结束&quot;);    }}``````package com.dynamoProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class LastProxy implements InvocationHandler {    //调用对象    private Object proxy;    //目标对象    private Object target;    public Object bind(Object target, Object proxy) {        this.target = target;        this.proxy = proxy;        return Proxy.newProxyInstance(this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this);    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        Object result = null;        //反射得到操作者的实例        Class clazz = this.proxy.getClass();        //反射得到操作者的preLogin方法        Method start = clazz.getDeclaredMethod(&quot;preLogin&quot;);        //反射执行start方法        start.invoke(this.proxy);        //执行要处理对象的原本方法        method.invoke(this.target, args);        //反射得到操作者的endLogin方法        Method end = clazz.getDeclaredMethod(&quot;endLogin&quot;);        //反射执行end方法        end.invoke(this.proxy);        return result;    }}```</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>理解了代理模式之后，再来看看spring AOP，它需要我们在配置文件中配置哪些东西就一目了然了- 配置目标对象 即上面的CommentImpl类- 配置advice对象 即上面的LoginImpl类- 配置ProxyFactoryBean对象 即我们的LastProxy类，只不过这个类，spring已经帮我们写了。我们只需要传递一些参数进去即可，spring AOP的代理模式有两种JDKProxy和CGLIBProxy，默认使用JDKProxy，JDKProxy是基于接口的，实现类必须实现接口</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之mybaits分表shardbatis</title>
    <link href="undefined2017/08/20/java_mybatis_shardbatis/"/>
    <url>2017/08/20/java_mybatis_shardbatis/</url>
    
    <content type="html"><![CDATA[<h3 id="java之mybaits分表shardbatis"><a href="#java之mybaits分表shardbatis" class="headerlink" title="java之mybaits分表shardbatis"></a>java之mybaits分表shardbatis</h3><pre><code>Shardbatis的名称由shard(ing)+mybatis组合得到，诣在为mybatis实现数据水平切分的功能。数据的水平切分包括多数据库的切分和多表的数据切分，目前shardbatis只实现了单数据库的数据多表水平切分。Shardbatis2.0以插件的方式和mybatis3.x进行整合，对mybatis的代码无侵入，不改变用户对mybatis的使用习惯。</code></pre><h4 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h4><ul><li><p>0.<a href="https://github.com/colddew/shardbatis" target="_blank" rel="noopener">https://github.com/colddew/shardbatis</a></p></li><li><p>1.导入依赖包</p><ul><li>lib/jsqlparser-0.7.2.jar</li><li>lib/shardbatis-2.1.0.jar</li></ul></li><li><p>2.在应用的classpath中添加sharding配置文件shard_config.xml</p></li></ul><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE shardingConfig PUBLIC &quot;-//shardbatis.googlecode.com//DTD Shardbatis 2.0//EN&quot;        &quot;http://shardbatis.googlecode.com/dtd/shardbatis-config.dtd&quot;&gt;&lt;shardingConfig&gt;    &lt;!--        parseList可选配置        如果配置了parseList,只有在parseList范围内并且不再ignoreList内的sql才会被解析和修改    --&gt;    &lt;ignoreList&gt;        &lt;value&gt;xxx.xxx&lt;/value&gt;    &lt;/ignoreList&gt;    &lt;parseList&gt;        &lt;value&gt;com.database.mapper.UserMapper.findUserById&lt;/value&gt;        &lt;value&gt;com.database.mapper.UserMapper.insertUser&lt;/value&gt;        &lt;value&gt;com.database.mapper.UserMapper.deleteUser&lt;/value&gt;        &lt;value&gt;com.database.mapper.OrdersMapperCustom.findOrderUser&lt;/value&gt;        &lt;value&gt;com.database.mapper.OrdersMapperCustom.findOrderUserResultMap&lt;/value&gt;        &lt;value&gt;com.database.mapper.OrdersMapperCustom.findUserAndItemsResultMap&lt;/value&gt;    &lt;/parseList&gt;    &lt;!--        配置分表策略        tableName指的是实际的表名，strategyClass对应的分表策略实现类    --&gt;    &lt;strategy tableName=&quot;user&quot; strategyClass=&quot;com.database.mapper.UserShardStrategyImpl&quot;/&gt;    &lt;strategy tableName=&quot;orders&quot; strategyClass=&quot;com.database.mapper.OrdersShardStrategyImpl&quot;/&gt;    &lt;strategy tableName=&quot;items&quot; strategyClass=&quot;com.database.mapper.ItemsShardStrategyImpl&quot;/&gt;&lt;/shardingConfig&gt;</code></pre><ul><li><p>3.在mybatis配置文件中添加</p><pre><code>&lt;plugins&gt;  &lt;plugin interceptor=&quot;com.google.code.shardbatis.plugin.ShardPlugin&quot;&gt;      &lt;property name=&quot;shardingConfig&quot; value=&quot;shard_config.xml&quot;/&gt;  &lt;/plugin&gt;&lt;/plugins&gt;</code></pre></li><li><p>4.实现自定义sharding策略</p></li></ul><pre><code>/*** 分表策略接口*/public interface ShardStrategy {    /**     * 得到实际表名     * @param baseTableName 逻辑表名,一般是没有前缀或者是后缀的表名     * @param params mybatis执行某个statement时使用的参数     * @param mapperId mybatis配置的statement id     * @return 实际表名     */    String getTargetTableName(String baseTableName,Object params,String mapperId);}public class XXXShardStrategy implements ShardStrategy {    @Override    public String getTargetTableName(String baseTableName, Object params, String mapperId) {        return baseTableName + getTableNameSuffix(params);    }    private String getTableNameSuffix(Object params) {        // 例如可以根据用户id求余或者hash获取表名后缀    }}</code></pre><ul><li><p>5.使用<br>  通过以上配置已经完成了所有配置，因为shardbatis2.0使用插件方式对mybatis功能进行增强，代码无侵入，因此使用配置了shardbatis的mybatis3和使用原生的mybatis3没有区别</p></li><li><p>6.注意事项</p><ol><li>2.0版本中inser、update、delete语句中的子查询语句中的表不支持sharding  </li><li>select语句中如果进行多表关联，请务必为每个表名加上别名，例如原始sql语句：SELECT a.* FROM ANTIQUES a, ANTIQUEOWNERS b, mytable c where a.id=b.id and b.id=c.id 经过转换后的结果可能为：SELECT a.* FROM ANTIQUES_0 AS a, ANTIQUEOWNERS_1 AS b, mytable_1 AS c WHERE a.id = b.id AND b.id = c.id  </li></ol></li><li><p>7.源码简析</p></li></ul><pre><code>package com.google.code.shardbatis.plugin;import com.google.code.shardbatis.builder.ShardConfigHolder;import com.google.code.shardbatis.builder.ShardConfigParser;import com.google.code.shardbatis.converter.SqlConverterFactory;import com.google.code.shardbatis.util.ReflectionUtils;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;import java.lang.reflect.Proxy;import java.sql.Connection;import java.util.Properties;import java.util.concurrent.ConcurrentHashMap;import org.apache.ibatis.executor.statement.RoutingStatementHandler;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.io.Resources;import org.apache.ibatis.logging.Log;import org.apache.ibatis.logging.LogFactory;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.Interceptor;import org.apache.ibatis.plugin.Intercepts;import org.apache.ibatis.plugin.Invocation;import org.apache.ibatis.plugin.Plugin;import org.apache.ibatis.plugin.Signature;@Intercepts({@Signature(    type = StatementHandler.class,    method = &quot;prepare&quot;,    args = {Connection.class})})public class ShardPlugin implements Interceptor {    private static final Log log = LogFactory.getLog(ShardPlugin.class);    public static final String SHARDING_CONFIG = &quot;shardingConfig&quot;;    private static final ConcurrentHashMap&lt;String, Boolean&gt; cache = new ConcurrentHashMap();    public ShardPlugin() {    }    public Object intercept(Invocation invocation) throws Throwable {        StatementHandler statementHandler = (StatementHandler)invocation.getTarget();        Plugin plugin;        if (Proxy.isProxyClass(statementHandler.getClass())) {            plugin = (Plugin)Proxy.getInvocationHandler(statementHandler);            if (plugin != null) {                Field targetField = plugin.getClass().getDeclaredField(&quot;target&quot;);                targetField.setAccessible(true);                statementHandler = (StatementHandler)targetField.get(plugin);            }        }        //通过反射得到statementid，获取statement的sql        plugin = null;        MappedStatement mappedStatement;        if (statementHandler instanceof RoutingStatementHandler) {            StatementHandler delegate = (StatementHandler)ReflectionUtils.getFieldValue(statementHandler, &quot;delegate&quot;);            mappedStatement = (MappedStatement)ReflectionUtils.getFieldValue(delegate, &quot;mappedStatement&quot;);        } else {            mappedStatement = (MappedStatement)ReflectionUtils.getFieldValue(statementHandler, &quot;mappedStatement&quot;);        }        String mapperId = mappedStatement.getId();        if (this.isShouldParse(mapperId)) {            String sql = statementHandler.getBoundSql().getSql();            if (log.isDebugEnabled()) {                log.debug(&quot;Original Sql [&quot; + mapperId + &quot;]:&quot; + sql);            }        //获取statement传递的参数，存到params中            Object params = statementHandler.getBoundSql().getParameterObject();        //调用SqlConverterFactory工厂类，执行convert方法，其中会执行我们刚才自定义的getTargetTableName方法            SqlConverterFactory cf = SqlConverterFactory.getInstance();            sql = cf.convert(sql, params, mapperId);            if (log.isDebugEnabled()) {                log.debug(&quot;Converted Sql [&quot; + mapperId + &quot;]:&quot; + sql);            }            ReflectionUtils.setFieldValue(statementHandler.getBoundSql(), &quot;sql&quot;, sql);        }        return invocation.proceed();    }    public Object plugin(Object target) {        return Plugin.wrap(target, this);    }    public void setProperties(Properties properties) {        String config = properties.getProperty(&quot;shardingConfig&quot;, (String)null);        if (config != null &amp;&amp; config.trim().length() != 0) {            ShardConfigParser parser = new ShardConfigParser();            InputStream input = null;            try {                input = Resources.getResourceAsStream(config);                parser.parse(input);            } catch (IOException var14) {                log.error(&quot;Get sharding config file failed.&quot;, var14);                throw new IllegalArgumentException(var14);            } catch (Exception var15) {                log.error(&quot;Parse sharding config file failed.&quot;, var15);                throw new IllegalArgumentException(var15);            } finally {                if (input != null) {                    try {                        input.close();                    } catch (IOException var13) {                        log.error(var13.getMessage(), var13);                    }                }            }        } else {            throw new IllegalArgumentException(&quot;property &#39;shardingConfig&#39; is requested.&quot;);        }    }    private boolean isShouldParse(String mapperId) {        Boolean parse = (Boolean)cache.get(mapperId);        if (parse != null) {            return parse;        } else {            if (!mapperId.endsWith(&quot;!selectKey&quot;)) {                ShardConfigHolder configHolder = ShardConfigHolder.getInstance();                if (!configHolder.isIgnoreId(mapperId) &amp;&amp; (!configHolder.isConfigParseId() || configHolder.isParseId(mapperId))) {                    parse = true;                }            }            if (parse == null) {                parse = false;            }            cache.put(mapperId, parse);            return parse;        }    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之注解使用案例解析</title>
    <link href="undefined2017/06/03/java_Annotation_learning/"/>
    <url>2017/06/03/java_Annotation_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="java之注解使用案例解析"><a href="#java之注解使用案例解析" class="headerlink" title="java之注解使用案例解析"></a>java之注解使用案例解析</h2><h4 id="啥是注解"><a href="#啥是注解" class="headerlink" title="啥是注解"></a>啥是注解</h4><p>注解也叫元数据，例如我们常见的@Override和@Deprecated，注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解</p><p>一般常用的注解可以分为三类：</p><ul><li><p>一类是Java自带的标准注解，包括@Override（标明重写某个方法）、@Deprecated（标明某个类或方法过时）和@SuppressWarnings（标明要忽略的警告），使用这些注解后编译器就会进行检查</p></li><li><p>一类为元注解，元注解是用于定义注解的注解，包括@Retention（标明注解被保留的阶段）、@Target（标明注解使用的范围）、@Inherited（标明注解可继承）、@Documented（标明是否生成javadoc文档）</p></li><li><p>一类为自定义注解，可以根据自己的需求定义注解</p></li></ul><h4 id="注解用途"><a href="#注解用途" class="headerlink" title="注解用途"></a>注解用途</h4><ol><li><p>生成文档，通过代码里标识的元数据生成javadoc文档。</p></li><li><p>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</p></li><li><p>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</p></li><li><p>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</p></li></ol><h4 id="使用注解案例"><a href="#使用注解案例" class="headerlink" title="使用注解案例"></a>使用注解案例</h4><p>使用注解将dao层原本需要为每个table写的add（）方法合并成为一个。</p><p>未使用注解前：</p><p>代码片段结构  </p><ul><li>Dao<ul><li>UserDao.java</li><li>categoryDao.java</li></ul></li><li>Entity<ul><li>User.java</li><li>Category.java</li></ul></li></ul><pre><code>userDao.javapublic void add(User user){        try{            String sql = &quot;insert into tb_user value(?,?,?,?,?,?)&quot;;            Object[] params = {user.getUid(),user.getUsername(),user.getPassword(),user.getEmail(),user.getCode(),user.getState()};            qr.update(sql,params);        }catch (Exception e){            throw new RuntimeException(e.getMessage());        }    }categoryDao.java public String add(Category category){        try{            String cid = category.getCid();            String cname = category.getCname();            String sql = &quot;insert into category values(?,?)&quot;;            Object[] params = {cid,cname};            qr.update(sql,params);            return &quot;添加成功&quot;;        }catch (Exception e){            return &quot;添加失败&quot;;        }    }</code></pre><p>使用注解后：</p><p>代码片段结构  </p><ul><li>Dao<ul><li>UserDao.java</li><li>categoryDao.java</li><li>BaseDao.java</li></ul></li><li>Entity<ul><li>UserTest.java</li><li>CategoryTest.java</li></ul></li><li>Annotation<ul><li>GetMe.java</li><li>Column.java</li><li>ID.java</li></ul></li></ul><pre><code>UserDao.javapublic class TestDao extends BaseDao&lt;UserTest&gt; {    public void useradd(UserTest user) throws SQLException, NoSuchFieldException, InvocationTargetException, IllegalAccessException {        super.add(user);    }categoryDao.javapublic class TestDao2 extends BaseDao&lt;CategoryTest&gt; {    public void categoryadd(CategoryTest category) throws SQLException, NoSuchFieldException, InvocationTargetException, IllegalAccessException {        super.add(category);    }BaseDao.javapublic class BaseDao&lt;T&gt; {    private QueryRunner qr = new TxQueryRunner();    public void add(T bean) throws SQLException, NoSuchFieldException, InvocationTargetException, IllegalAccessException {        //获取子类传来的对象，并获取该对象的类        Class c = bean.getClass();        //获取该类下自己定义的所有类属性，通过反射得到注解的值        Field[] fields = c.getDeclaredFields();        for(Field field:fields){            if(&quot;uid&quot;.equals(field.getName()) || &quot;cid&quot;.equals(field.getName())){                ID id = field.getDeclaredAnnotation(ID.class);                System.out.println(id.value());            }else {                Column filedLearn = field.getDeclaredAnnotation(Column.class);                System.out.println(filedLearn.value());            }        }        //获取该类下自己定义的所有方法，通过反射得到注解的值，写入有序的map中        Map&lt;String,Object&gt; map = new LinkedHashMap&lt;String,Object&gt;();        Method[] medthods = c.getDeclaredMethods();        for (Method method:medthods             ) {            if(method.getName().startsWith(&quot;get&quot;)){                System.out.println(method.getName());                GetMe getme = method.getDeclaredAnnotation(GetMe.class);                System.out.println(getme);                map.put(getme.param(),method.invoke(bean));            }        }        //通过反射获取该类的注解，注解的值设置为类所对应的数据库table名称        Table mytabl = (Table) c.getAnnotation(Table.class);        System.out.println(mytabl.value());        String pa = &quot;?,&quot; ;        for (int i = 1; i &lt; fields.length; i++) {            pa += &quot;?&quot;;            if(i&lt;fields.length-1){                pa +=&quot;,&quot;;            }        }        //动态构建sql和params，执行qr.update        StringBuffer buf=new StringBuffer();        buf.append(&quot;insert into &quot;);        buf.append(mytabl.value());        buf.append(&quot;(&quot;);        String sqlkey = String.join(&quot;,&quot;,map.keySet());        buf.append(sqlkey);        buf.append(&quot;) &quot;);        buf.append(&quot; values(&quot;);        buf.append(pa);        buf.append(&quot;)&quot;);        String sql=buf.toString();        System.out.println(sql);        Object[] params = map.values().toArray();        System.out.println(params);        qr.update(sql,params);    }}</code></pre><pre><code>CategoryTest.javapackage com.facesun.test;@Table(&quot;category&quot;)public class CategoryTest {        @ID(&quot;cid&quot;)        private String cid;        @Column(&quot;cname&quot;)        private String cname;       @GetMe(param=&quot;cid&quot;)        public String getCid() {        return cid;    }        public void setCid(String cid) {        this.cid = cid;    }    @GetMe(param=&quot;cname&quot;)        public String getCname() {        return cname;    }        public void setCname(String cname) {        this.cname = cname;    }}</code></pre><pre><code>UserTest.javapackage com.facesun.test;@Table(&quot;tb_user&quot;)public class UserTest {    @ID(&quot;uid&quot;)    private String uid;    @Column(&quot;username&quot;)    private String username;    @Column(&quot;password&quot;)    private String password;    @Column(&quot;email&quot;)    private String email;    @Column(&quot;code&quot;)    private String code;    @Column(&quot;state&quot;)    private Boolean state;    @GetMe(param=&quot;uid&quot;)    public String getUid() {        return uid;    }    public void setUid(String uid) {        this.uid = uid;    }    @GetMe(param=&quot;username&quot;)    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    @GetMe(param=&quot;password&quot;)    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    @GetMe(param=&quot;email&quot;)    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    @GetMe(param = &quot;code&quot;)    public String getCode() {        return code;    }    public void setCode(String code) {        this.code = code;    }    @GetMe(param = &quot;state&quot;)    public Boolean getState() {        return state;    }    public void setState(Boolean state) {        this.state = state;    }}</code></pre><pre><code>GetMe.javapackage com.facesun.test;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface GetMe {    String param();}Column.javapackage com.facesun.test;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface Column {    String value();}ID.javapackage com.facesun.test;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface ID {    String value();}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>google oauth python 认证流程详解</title>
    <link href="undefined2016/12/01/google_auth_python/"/>
    <url>2016/12/01/google_auth_python/</url>
    
    <content type="html"><![CDATA[<h4 id="一：从谷歌开发者控制台获得-OAuth-2-0-凭证"><a href="#一：从谷歌开发者控制台获得-OAuth-2-0-凭证" class="headerlink" title="一：从谷歌开发者控制台获得 OAuth 2.0 凭证"></a>一：从谷歌开发者控制台获得 OAuth 2.0 凭证</h4><p>  <code>前往&#39;https://console.developers.google.com&#39;&gt;&gt;创建凭据&gt;&gt;选择Oauth客户端id&gt;&gt;网页应用&gt;&gt;输入域名和callback函数地址&gt;&gt;获取client_id以及client_sercert</code></p><h4 id="二：从谷歌授权服务器获得一个访问密钥"><a href="#二：从谷歌授权服务器获得一个访问密钥" class="headerlink" title="二：从谷歌授权服务器获得一个访问密钥"></a>二：从谷歌授权服务器获得一个访问密钥</h4><p>   <code>https://accounts.google.com/o/oauth2/auth?scope=%s&amp;response_type=code&amp;client_id=%s&amp;redirect_uri=%s&amp;hd=%s</code><br>   <code>其中scope为指定授权的范围，如希望获取用户信息scope=&#39;https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/userinfo.profile&#39;</code><br>   <code>其中response_type=code，指返回的类型为code</code><br>  <code>其中client_id为上一步client_id</code><br>   <code>其中redirect_uri为上一步的回调函数</code><br>   <code>其中hd为认证邮箱的后缀限制，可选</code>  </p><h4 id="三：使用上一步返回的code，去请求acess-token"><a href="#三：使用上一步返回的code，去请求acess-token" class="headerlink" title="三：使用上一步返回的code，去请求acess_token"></a>三：使用上一步返回的code，去请求acess_token</h4><pre><code>post请求https://accounts.google.com/o/oauth2/token需要的参数有    &#39;code&#39;:code,    &#39;client_id&#39;: client_id,    &#39;client_secret&#39;: client_secret,    &#39;redirect_uri&#39;: redirect_uri,    &#39;grant_type&#39;:&#39;authorization_code&#39;,</code></pre><h4 id="四：使用上一步的access-token，获取用户信息"><a href="#四：使用上一步的access-token，获取用户信息" class="headerlink" title="四：使用上一步的access_token，获取用户信息"></a>四：使用上一步的access_token，获取用户信息</h4><pre><code>https://www.googleapis.com/oauth2/v1/userinfo?access_token=%s</code></pre><p>示例：</p><pre><code>client_id = &#39;46842-ohl9n34rpmu416sl86gc6aac378m661v.apps.googleusercontent.com&#39;client_secret = &#39;~~~~~~~~N-PRy_SJGxdB&#39;redirect_uri=&#39;http://test-gitlab.yourdomain.com/login/callback&#39;scope=&#39;https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/userinfo.profile&#39;import requests,jsonfrom flask import Flask,requestfrom flask import redirectapp = Flask(__name__)@app.route(&#39;/client/login&#39;,methods=[&#39;POST&#39;,&#39;GET&#39;])def client_login():    uri = &#39;https://accounts.google.com/o/oauth2/auth?scope=%s&amp;response_type=code&amp;client_id=%s&amp;redirect_uri=%s&amp;hd=%s&#39; %(scope,client_id,redirect_uri,&#39;yourdomain.com&#39;)    return redirect(uri)@app.route(&#39;/login/callback&#39;, methods=[&#39;POST&#39;, &#39;GET&#39;])def oauth():   code=request.args.get(&#39;code&#39;)   #google_api = &#39;https://www.googleapis.com/oauth2/v1/userinfo?access_token=%s&#39;%(code)   baseurl = &#39;https://accounts.google.com/o/oauth2/token&#39;   data = {        &#39;code&#39;:code,        &#39;client_id&#39;: client_id,        &#39;client_secret&#39;: client_secret,        &#39;redirect_uri&#39;: redirect_uri,        &#39;grant_type&#39;:&#39;authorization_code&#39;,    }   res = requests.post(url=baseurl,data=data)   info = json.loads(res.text)   print(info.get(&#39;access_token&#39;))   google_api = &#39;https://www.googleapis.com/oauth2/v1/userinfo?access_token=%s&#39;%(info.get(&#39;access_token&#39;))   return redirect(google_api)if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax使用及数据转换</title>
    <link href="undefined2016/08/29/ajax_learning/"/>
    <url>2016/08/29/ajax_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="ajax使用及数据转换"><a href="#ajax使用及数据转换" class="headerlink" title="ajax使用及数据转换"></a>ajax使用及数据转换</h2><h3 id="1-ajax是什么"><a href="#1-ajax是什么" class="headerlink" title="1. ajax是什么"></a>1. ajax是什么</h3><ul><li>asynchronous javascript and xml：异步的js和xml</li><li>它能使用js访问服务器，而且是异步访问！</li><li>服务器给客户端的响应一般是整个页面，一个html完整页面！但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面！而只是数据！</li></ul><h3 id="ajax发送请求的基本步骤"><a href="#ajax发送请求的基本步骤" class="headerlink" title="ajax发送请求的基本步骤"></a>ajax发送请求的基本步骤</h3><h4 id="1-第一步（得到XMLHttpRequest）"><a href="#1-第一步（得到XMLHttpRequest）" class="headerlink" title="1. 第一步（得到XMLHttpRequest）"></a>1. 第一步（得到XMLHttpRequest）</h4><ul><li><p>ajax其实只需要学习一个对象：XMLHttpRequest，如果掌握了它，就掌握了ajax！！！</p></li><li><p>得到XMLHttpRequest</p><blockquote><p>大多数浏览器都支持：var xmlHttp = new XMLHttpRequest();<br>IE6.0：var xmlHttp = new ActiveXObject(“Msxml2.XMLHTTP”);<br>IE5.5以更早版本的IE：var xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”);</p></blockquote></li><li><p>编写创建XMLHttpRequest对象的函数</p><pre><code>function createXMLHttpRequest() {  try {      return new XMLHttpRequest();  } catch(e) {      try {      return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);  } catch(e) {      try {          return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);      } catch(e) {          alert(&quot;哥们儿，你用的是什么浏览器啊？&quot;);          throw e;      }  }  }}</code></pre></li></ul><h4 id="2-第二步（打开与服务器的连接）"><a href="#2-第二步（打开与服务器的连接）" class="headerlink" title="2. 第二步（打开与服务器的连接）"></a>2. 第二步（打开与服务器的连接）</h4><ul><li>xmlHttp.open()：用来打开与服务器的连接，它需要三个参数：<blockquote><p>请求方式：可以是GET或POST<br>请求的URL：指定服务器端资源，例如；/AServlet<br>请求是否为异步：如果为true表示发送异步请求，否则同步请求！</p></blockquote></li><li>xmlHttp.open(“GET”, “/AServlet”, true);</li></ul><h4 id="3-第三步（发送请求）"><a href="#3-第三步（发送请求）" class="headerlink" title="3. 第三步（发送请求）"></a>3. 第三步（发送请求）</h4><ul><li>xmlHttp.send(null)：如果不给可能会造成部份浏览器无法发送！<blockquote><p>参数：就是请求体内容！如果是GET请求，必须给出null。</p></blockquote></li></ul><h4 id="4-第四步（）"><a href="#4-第四步（）" class="headerlink" title="4. 第四步（）"></a>4. 第四步（）</h4><ul><li><p>在xmlHttp对象的一个事件上注册监听器：onreadystatechange</p></li><li><p>xmlHttp对象一共有5个状态：</p><blockquote><p>0状态：刚创建，还没有调用open()方法;<br>1状态：请求开始：调用了open()方法，但还没有调用send()方法<br>2状态：调用完了send()方法了；<br>3状态：服务器已经开始响应，但不表示响应结束了！<br>4状态：服务器响应结束！（通常我们只关心这个状态！！！）</p></blockquote></li><li><p>得到xmlHttp对象的状态：</p><blockquote><p>var state = xmlHttp.readyState;//可能是0、1、2、3、4</p></blockquote></li><li><p>得到服务器响应的状态码</p><blockquote><p>var status = xmlHttp.status;//例如为200、404、500</p></blockquote></li><li><p>得到服务器响应的内容1</p><pre><code>&gt; var content = xmlHttp.responseText;//得到服务器的响应的文本格式的内容&gt; var content = xmlHttp.responseXML;//得到服务器的响应的xml响应的内容，它是Document对象了！xmlHttp.onreadystatechange = function() {//xmlHttp的5种状态都会调用本方法  if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {//双重判断：判断是否为4状态，而且还要判断是否为200      // 获取服务器的响应内容  var text = xmlHttp.responseText;  }};</code></pre></li></ul><h3 id="Demo1-ajax简单的请求jsp"><a href="#Demo1-ajax简单的请求jsp" class="headerlink" title="Demo1 ajax简单的请求jsp"></a>Demo1 ajax简单的请求jsp</h3><pre><code>### ajax.jsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Ajax&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function createXMLHttpRequest(){    try{        return new XMLHttpRequest();    }catch (e) {        alert(&quot;垃圾浏览器&quot;);    }}window.onload = function () {    //点击button，ajax通过get方式获取数据  var btn = document.getElementById(&quot;btnGet&quot;);  btn.onclick = function () {      var xmlHttp = createXMLHttpRequest();      xmlHttp.open(&quot;GET&quot;,&quot;&lt;c:url value=&quot;/AjaxServlet&quot;/&gt;&quot;,true);      xmlHttp.send(null);      xmlHttp.onreadystatechange = function(){          if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200){             var text =  xmlHttp.responseText;             var od = document.getElementById(&quot;showGet&quot;);             od.innerHTML =text;          }      }  };  //点击button，ajax通过post方式获取数据  var postbtn = document.getElementById(&quot;btnPost&quot;);  postbtn.onclick = function () {      var xmlHttp = createXMLHttpRequest();      xmlHttp.open(&quot;POST&quot;,&quot;&lt;c:url value=&quot;/AjaxServlet&quot;/&gt;&quot;,true);      xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);      xmlHttp.send(&quot;username=张三&amp;password=1234&quot;);      xmlHttp.onreadystatechange = function(){          if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200){              var text =  xmlHttp.responseText;              var od = document.getElementById(&quot;showpost&quot;);              od.innerHTML =text;          }      }  }//输入信息离开input后，ajax通过post方式获取数据    var username = document.getElementById(&quot;username&quot;);    username.onblur = function () {        var xmlHttp = createXMLHttpRequest();        xmlHttp.open(&quot;POST&quot;,&quot;&lt;c:url value=&quot;/AjaxServlet&quot;/&gt;&quot;,true);        xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);        xmlHttp.send(&quot;username=&quot;+username.value+&quot;&amp;password=1234&quot;);        xmlHttp.onreadystatechange = function(){            if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200){                var text =  xmlHttp.responseText;                var od = document.getElementById(&quot;errormsg&quot;);                od.innerHTML =text;            }        }    }};&lt;/script&gt;&lt;body&gt;&lt;button id=&quot;btnGet&quot; value=&quot;button&quot;&gt;ajaxGET&lt;/button&gt;&lt;h2 id=&quot;showGet&quot; &gt;&lt;/h2&gt;&lt;button id=&quot;btnPost&quot;&gt;ajaxPost&lt;/button&gt;&lt;h2 id=&quot;showpost&quot;&gt;&lt;/h2&gt;username:&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;span id=&quot;errormsg&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>## AjaxServlet.javapackage com.ajax.now;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(name = &quot;AjaxServlet&quot;)public class AjaxServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println(&quot;post&quot;);        String username = request.getParameter(&quot;username&quot;);        String password = request.getParameter(&quot;password&quot;);        if (username.contains(&quot;admin&quot;)){            response.getWriter().print(&quot;用户名包含admin&quot;+username+password);        }else {            response.getWriter().print(&quot;用户名不包含admin&quot;+username+password);        }    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        System.out.println(&quot;来时come去是go&quot;);        response.getWriter().print(&quot;hello world&quot;);    }}</code></pre><h3 id="Demo2-省市联动"><a href="#Demo2-省市联动" class="headerlink" title="Demo2 省市联动"></a>Demo2 省市联动</h3><ul><li>ProvinceAjax.jsp   负责在页面加载时发送ajax请求，获取省份的数据，增加到省份的select标签下，当用户选择省份后，触发onchanage事件，发送ajax请求获取该省份的城市数据，增加到城市的select标签下</li><li>ProvinceServlet.java<br>负责接收ajax的get请求返回所有省份的数据</li><li>CityServlet.java<br>负责接收ajax的post请求，根据传来数据返回响应的城市数据</li><li>pro.xml<br>负责存储省市联动的xml数据</li></ul><pre><code>## ProvinceAjax.jsp   &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function createXMLHttpRequest(){        try{            return new XMLHttpRequest();        }catch (e) {            alert(&quot;垃圾浏览器&quot;);        }    }    window.onload = function () {        var xmlHttp = createXMLHttpRequest();        xmlHttp.open(&quot;GET&quot;,&quot;&lt;c:url value=&quot;/ProvinceServlet&quot;/&gt;&quot;,true);        xmlHttp.send(null);        xmlHttp.onreadystatechange = function(){            if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200){                var text =  xmlHttp.responseText;                var provincelist = text.split(&quot;,&quot;);                var pro = document.getElementById(&quot;province&quot;);                for(i=0;i&lt;provincelist.length;i++) {                    var op = document.createElement(&quot;option&quot;);                    op.value = provincelist[i];                    var textNode = document.createTextNode(provincelist[i]);                    op.appendChild(textNode);                    pro.appendChild(op);                }        }    };        var provincebtn = document.getElementById(&quot;province&quot;);        provincebtn.onchange = function () {            var xmlHttp = createXMLHttpRequest();            xmlHttp.open(&quot;POST&quot;,&quot;&lt;c:url value=&quot;/CityServlet&quot;/&gt;&quot;,true);            xmlHttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);            xmlHttp.send(&quot;province=&quot;+provincebtn.value);            xmlHttp.onreadystatechange = function(){                if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200){                    var cityselect = document.getElementById(&quot;city&quot;);                    var optionElement = cityselect.getElementsByTagName(&quot;option&quot;);                    while (optionElement.length &gt;1){                        cityselect.removeChild(optionElement[1]);                    }                    var doc =  xmlHttp.responseXML;                    var cityList = doc.getElementsByTagName(&quot;city&quot;);                    for(var i=0;i&lt;cityList.length;i++){                        var cityele = cityList[i];                        cityName = cityele.textContent;                        var op = document.createElement(&quot;option&quot;);                        op.value = cityName;                        var textNode = document.createTextNode(cityName);                        op.appendChild(textNode);                        cityselect.appendChild(op);                    }                }            }        }    }&lt;/script&gt;&lt;head&gt;    &lt;title&gt;Province&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;select id=&quot;province&quot; &gt;    &lt;option &gt;请选择省份&lt;/option&gt;&lt;/select&gt;&lt;select id=&quot;city&quot;&gt;    &lt;option &gt;请选择城市&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>## ProvinceServlet.javapackage com.ajax.now;import org.dom4j.*;import org.dom4j.io.SAXReader;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.List;@WebServlet(name = &quot;ProvinceServlet&quot;)public class ProvinceServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        request.setCharacterEncoding(&quot;GBK&quot;);        response.setContentType(&quot;text/html;charset=GBK&quot;);        SAXReader reader = new SAXReader();        Document document = null;        try {            InputStream input = this.getClass().getResourceAsStream(&quot;/pro.xml&quot;);            document = reader.read(input);            Element root = document.getRootElement();            List&lt;Node&gt; arrList = root.selectNodes(&quot;//province//@name&quot;);            StringBuilder sb = new StringBuilder();            for (int i=0;i&lt; arrList.size();i++            ) {                sb.append(arrList.get(i).getStringValue());                if (i &lt; arrList.size()-1){                    sb.append(&quot;,&quot;);                }            }            response.getWriter().print(sb);        } catch (DocumentException e) {            System.out.println(e.getMessage());        }    }}</code></pre><pre><code>## CityServlet.javapackage com.ajax.now;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.List;@WebServlet(name = &quot;CityServlet&quot;)public class CityServlet extends HttpServlet {    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        /*         * 获取省份名称         * 使用省份名称得到对应的province元素         * 把元素转换成字符串发送         * */        request.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;text/xml;charset=utf-8&quot;);        String province = request.getParameter(&quot;province&quot;);        SAXReader reader = new SAXReader();        Document document = null;        try {            InputStream input = this.getClass().getResourceAsStream(&quot;/pro.xml&quot;);            document = reader.read(input);            Element root = document.getRootElement();            Node node = root.selectSingleNode(&quot;//province[@name=&#39;&quot; + province + &quot;&#39;]&quot;);            String xmlStr = node.asXML();            response.getWriter().print(xmlStr);        } catch (DocumentException e) {            System.out.println(e.getMessage());        }    }}</code></pre><pre><code>## pro.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;country&gt;    &lt;province name=&quot;北京&quot;&gt;        &lt;city&gt;海淀&lt;/city&gt;        &lt;city&gt;昌平&lt;/city&gt;        &lt;city&gt;朝阳&lt;/city&gt;    &lt;/province&gt;    &lt;province name=&quot;辽宁&quot;&gt;        &lt;city&gt;沈阳&lt;/city&gt;        &lt;city&gt;锦州&lt;/city&gt;        &lt;city&gt;大连&lt;/city&gt;    &lt;/province&gt;    &lt;province name=&quot;河北&quot;&gt;        &lt;city&gt;保定&lt;/city&gt;        &lt;city&gt;石家庄&lt;/city&gt;        &lt;city&gt;廊坊&lt;/city&gt;    &lt;/province&gt;&lt;/country&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之servlet源码初探</title>
    <link href="undefined2016/08/06/java_Servlet_learning/"/>
    <url>2016/08/06/java_Servlet_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="servlet源码初探"><a href="#servlet源码初探" class="headerlink" title="servlet源码初探"></a>servlet源码初探</h2><h4 id="servlet为javaweb的三大组件之一，servlet作用："><a href="#servlet为javaweb的三大组件之一，servlet作用：" class="headerlink" title="servlet为javaweb的三大组件之一，servlet作用："></a>servlet为javaweb的三大组件之一，servlet作用：</h4><ul><li>接收请求数据  </li><li>处理请求  </li><li>完成响应  </li></ul><h4 id="实现servlet的三种方式"><a href="#实现servlet的三种方式" class="headerlink" title="实现servlet的三种方式"></a>实现servlet的三种方式</h4><ul><li>实现javax.servlet.Servlet接口</li><li>继承javax.servlet.GenericServlet类</li><li>继承javax.servlet.http.HttpServlet类</li></ul><h5 id="实现javax-servlet-Servlet接口"><a href="#实现javax-servlet-Servlet接口" class="headerlink" title="实现javax.servlet.Servlet接口"></a>实现javax.servlet.Servlet接口</h5><p>重写Servlet的五个方法</p><pre><code class="$xslt">public class Aservlet implements Servlet {    /*    * 生命周期方法    * 在Servlet被创建后调用，并且只会被调用一次    * */    @Override    public void init(ServletConfig servletConfig) throws ServletException {        System.out.println(&quot;init.....&quot;);    }    /*     *     * 获取servlet的配置信息     * */    @Override    public ServletConfig getServletConfig() {        System.out.println(&quot;getServletConfig......&quot;);        return null;    }    /*     * 生命周期方法     * 每次处理请求都是在调用这个方法，故会被调用多次     * */    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        System.out.println(&quot;service/.........&quot;);    }    /*     *     * 获取servlet的信息     * */    @Override    public String getServletInfo() {        System.out.println(&quot;getServletInfo.........&quot;);        return null;    }    /*     * 生命周期方法     * 在Servlet被销毁前调用，并且只会被调用一次     * */    @Override    public void destroy() {        System.out.println(&quot;destroy............&quot;);    }}</code></pre><p>特性：</p><ul><li>单例，一个servlet类只有一个对象</li><li>线程不安全</li></ul><p>注意:  </p><ul><li>servlet类由我们写</li><li>servlet中的对象由tomcat创建</li><li>servlet中的方法由tomcat来调用</li></ul><p>如何让浏览器访问servlet</p><p>给Servlet配置servlet路径，这需要在web.xml中对servlet进行配置  </p><pre><code>             &lt;servlet&gt;                 &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;                 &lt;servlet-class&gt;com.servlet.now.Aservlet&lt;/servlet-class&gt;             &lt;/servlet&gt;             &lt;servlet-mapping&gt;                 &lt;servlet-name&gt;xxx&lt;/servlet-name&gt;                 &lt;url-pattern&gt;/Aservlet&lt;/url-pattern&gt;             &lt;/servlet-mapping&gt;</code></pre><h5 id="继承javax-servlet-GenericServlet类"><a href="#继承javax-servlet-GenericServlet类" class="headerlink" title="继承javax.servlet.GenericServlet类"></a>继承javax.servlet.GenericServlet类</h5><p>GenericServlet类对Servlet接口进行了重写，故我们只需要重写最重要的service方法即可<br>值得注意的是，在GenericServlet类中定义了init()方法，采用子类和父类共同构建，既可以避免子类覆盖父类中必须的方法，也可以提供给子类自定义的空间</p><pre><code class="$xslt">public class Bservlet extends GenericServlet {    @Override        public void init() throws ServletException {             System.out.println(&quot;this is  my init......&quot;);        }    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        System.out.println(&quot;this is service......&quot;);    }}</code></pre><pre><code class="$xslt">//GenericServlet类中init()方法//package javax.servlet;import java.io.IOException;import java.io.Serializable;import java.util.Enumeration;public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {    private static final long serialVersionUID = 1L;    private transient ServletConfig config;    public GenericServlet() {    }    public void destroy() {    }    .......    public void init(ServletConfig config) throws ServletException {        this.config = config;        this.init();    }    public void init() throws ServletException {    }    ....}</code></pre><h5 id="继承javax-servlet-http-HttpServlet类"><a href="#继承javax-servlet-http-HttpServlet类" class="headerlink" title="继承javax.servlet.http.HttpServlet类"></a>继承javax.servlet.http.HttpServlet类</h5><p>HttpServlet类继承了GenericServlet类,主要对service()方法进行了重写，在生命周期的service()<br>中强制转换参数为http相关的类型，然后调用本类的service()，本类的service()方法根据请求方式的不同，调用doGet()或者doPost()方法<br>这样，我们只需要实现doGet() doPost()等相关方法即可，根据源码显示，如果子类不实现doGet()，会返回405</p><pre><code class="$xslt">//HttpServlet类中service()方法的实现细节package javax.servlet.http;public abstract class HttpServlet extends GenericServlet {    private static final long serialVersionUID = 1L;    private static final String METHOD_DELETE = &quot;DELETE&quot;;    private static final String METHOD_HEAD = &quot;HEAD&quot;;    private static final String METHOD_GET = &quot;GET&quot;;    private static final String METHOD_OPTIONS = &quot;OPTIONS&quot;;    private static final String METHOD_POST = &quot;POST&quot;;    private static final String METHOD_PUT = &quot;PUT&quot;;    private static final String METHOD_TRACE = &quot;TRACE&quot;;    private static final String HEADER_IFMODSINCE = &quot;If-Modified-Since&quot;;    private static final String HEADER_LASTMOD = &quot;Last-Modified&quot;;    private static final String LSTRING_FILE = &quot;javax.servlet.http.LocalStrings&quot;;    private static final ResourceBundle lStrings = ResourceBundle.getBundle(&quot;javax.servlet.http.LocalStrings&quot;);    public HttpServlet() {    }    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String protocol = req.getProtocol();        String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;);        if (protocol.endsWith(&quot;1.1&quot;)) {            resp.sendError(405, msg);        } else {            resp.sendError(400, msg);        }    } .........    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String protocol = req.getProtocol();        String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;);        if (protocol.endsWith(&quot;1.1&quot;)) {            resp.sendError(405, msg);        } else {            resp.sendError(400, msg);        }    }    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String method = req.getMethod();        long lastModified;        if (method.equals(&quot;GET&quot;)) {            lastModified = this.getLastModified(req);            if (lastModified == -1L) {                this.doGet(req, resp);            } else {                long ifModifiedSince;                try {                    ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);                } catch (IllegalArgumentException var9) {                    ifModifiedSince = -1L;                }                if (ifModifiedSince &lt; lastModified / 1000L * 1000L) {                    this.maybeSetLastModified(resp, lastModified);                    this.doGet(req, resp);                } else {                    resp.setStatus(304);                }            }        } else if (method.equals(&quot;HEAD&quot;)) {            lastModified = this.getLastModified(req);            this.maybeSetLastModified(resp, lastModified);            this.doHead(req, resp);        } else if (method.equals(&quot;POST&quot;)) {            this.doPost(req, resp);        } else if (method.equals(&quot;PUT&quot;)) {            this.doPut(req, resp);        } else if (method.equals(&quot;DELETE&quot;)) {            this.doDelete(req, resp);        } else if (method.equals(&quot;OPTIONS&quot;)) {            this.doOptions(req, resp);        } else if (method.equals(&quot;TRACE&quot;)) {            this.doTrace(req, resp);        } else {            String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);            Object[] errArgs = new Object[]{method};            errMsg = MessageFormat.format(errMsg, errArgs);            resp.sendError(501, errMsg);        }    }......    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        HttpServletRequest request;        HttpServletResponse response;        try {            request = (HttpServletRequest)req;            response = (HttpServletResponse)res;        } catch (ClassCastException var6) {            throw new ServletException(lStrings.getString(&quot;http.non_http&quot;));        }        this.service(request, response);    }}</code></pre><h4 id="httpservlet对象生命周期"><a href="#httpservlet对象生命周期" class="headerlink" title="httpservlet对象生命周期"></a>httpservlet对象生命周期</h4><ul><li><p>一、创建Servlet对象的时机</p><ol><li>Servlet容器启动时：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，<br>同时将ServletConfig对象作为参数来调用Servlet对象的init方法。  </li><li>在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet对象的service方法。  </li><li>Servlet的类文件被更新后，重新创建Servlet，Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的<load-on-startup>属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。  </load-on-startup></li></ol></li><li><p>二、销毁Servlet对象的时机</p><ol><li>Servlet容器停止或者重新启动：Servlet容器调用Servlet对象的destroy方法来释放资源。  </li></ol></li></ul><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>javaweb四大域对象：PageContext\ServletRequest\HttpSession\ServletContext<br>域对象必须有数据的存取功能，域对象内部有一个map用来存储数据</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之反射知识总结</title>
    <link href="undefined2016/08/05/java_Refelect_learning/"/>
    <url>2016/08/05/java_Refelect_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="java反射总结"><a href="#java反射总结" class="headerlink" title="java反射总结"></a>java反射总结</h2><h4 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h4><ul><li>在框架开发中，都是基于配置文件开发。在配置文件中配置了类，可以通过反射得到类中的所有内容</li><li>反射原理分析：<br>  1.首先需要把java文件保存到本地磁盘.java<br>  2.编译java文件，生成.class文件<br>  3.使用jvm把class文件通过类加载器加载到内存中<br>  4.class文件在内存中使用class类表示<br>  5.当使用反射时，首先需要获取到class类，得到这个类后，就可以得到class文件里的所有内容<br>  6.其中包括属性、构造方法、普通方法，分别对应类Filed、Constructor、Method  </li></ul><h4 id="反射操作"><a href="#反射操作" class="headerlink" title="反射操作"></a>反射操作</h4><ul><li><p>获取class类<br>  1.类名直接.class  </p><pre><code>      `Class class1 = Person.class;  `  </code></pre><p>  2.对象.getClass()  </p><pre><code>      `Class class2 = new Person().getClass(); `   </code></pre><p>  3.Class.forName  </p><pre><code>     `` Class class3 = Class.forName(&quot;com.reflect.www.Person&quot;);  ``</code></pre></li><li><p>不使用new获取类的实例且操作实例属性 </p><pre><code>   Class class3 = Class.forName(&quot;com.reflect.www.Person&quot;);     Person p3 = (Person) class3.newInstance();     p3.setName(&quot;zhangsan&quot;);     System.out.println(p3.getName());</code></pre></li><li><p>使用反射操作有参构造方法</p><pre><code>      Class class3 = Class.forName(&quot;com.reflect.www.Person&quot;);       Constructor cs = class3.getConstructor(String.class,String.class,int.class);      Person person = (Person) cs.newInstance(&quot;zhangsan&quot;,&quot;gray&quot;,12);      System.out.println(person.getName()+person.getBirth()+person.getAge());</code></pre></li><li><p>使用反射操作属性</p><pre><code>  Class pw = Class.forName(&quot;com.reflect.www.Person&quot;);  Person person = (Person) pw.newInstance();  Field field = pw.getDeclaredField(&quot;name&quot;);  field.setAccessible(true);  field.set(person,&quot;GUn&quot;);  System.out.println(field.get(person));</code></pre></li><li><p>使用反射操作普通方法</p><pre><code>  Class pw = Class.forName(&quot;com.reflect.www.Person&quot;);  Person person = (Person) pw.newInstance();  Method md = pw.getDeclaredMethod(&quot;setName&quot;, String.class);  md.invoke(person,&quot;fangyunchang&quot;);  System.out.println(person.getName());</code></pre><p>  **需要注意操作静态方法时，md.invoke(person,”fangyunchang”);中的第一个参数需要设置为null</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之泛型出现解决的问题</title>
    <link href="undefined2016/08/03/java_Generic_learning/"/>
    <url>2016/08/03/java_Generic_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="java泛型出现解决的问题"><a href="#java泛型出现解决的问题" class="headerlink" title="java泛型出现解决的问题"></a>java泛型出现解决的问题</h2><ul><li>编译不报错，执行报错<br><code>在没有泛型之前，使用如下代码，向集合中添加string和int类型两种不同的类型时，因为list默认类型是object类型，故编译正常。  但是在之后进行循环执行时，由于之前添加了Integer类型的值，会出现java.lang.ClassCastException的异常。</code></li></ul><pre><code>public class GenericTest {    public static void main(String[] args) {        List list = new ArrayList();        list.add(&quot;字符串1&quot;);        list.add(&quot;字符串2&quot;);        list.add(100);        for (int i = 0; i &lt; list.size(); i++) {            String name = (String) list.get(i); // 执行报错            System.out.println(&quot;name:&quot; + name);        }}</code></pre><ul><li>编译报错<br><code>在采用泛型写法，提前定义参数类型时，上面这种情况得到了一些改善，编译时就会发现报错</code>  </li></ul><pre><code>public class GenericTest {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;String&gt;();        list.add(&quot;字符串1&quot;);        list.add(&quot;字符串2&quot;);        list.add(100);//编译报错        for (int i = 0; i &lt; list.size(); i++) {            String name =  list.get(i);             System.out.println(&quot;name:&quot; + name);        }}</code></pre><ul><li>编译和执行都不报错<br><code>自定义实现泛型类，实现灵活传入各种类型</code>  </li></ul><pre><code>public class GernicTest {    public static void main(String[] args) {        List&lt;Box&gt; list = new ArrayList&lt;Box&gt;();        Box box = new Box(&quot;pop&quot;);        list.add(box);        Box box_int = new Box(123);        list.add(box_int);        for (int i = 0; i &lt; list.size(); i++) {            Box name = list.get(i);             System.out.println(&quot;name:&quot; + name.getData());        }}}class Box&lt;T&gt; {    private  T data;    public Box(){    }    public Box(T data){      this.data =data;    }    public T getData(){      return data;    }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>freeradius vpn mysql认证</title>
    <link href="undefined2014/11/02/freeradius_vpn_mysql/"/>
    <url>2014/11/02/freeradius_vpn_mysql/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这里实现使用搭建freeradius和mysql来验证vpn登录，实现L2TP由FreeRadius认证连接并由MySQL管理用户。</p></blockquote><h3 id="配置L2TP服务"><a href="#配置L2TP服务" class="headerlink" title="配置L2TP服务"></a>配置L2TP服务</h3><p>确保完整安装L2TP/IPSec服务，并能正常连接<br>确保sudo vim /etc/ipsec.secrets中的秘钥和freeradius里配置相同</p><pre><code>%any %any: PSK &quot;testing123&quot;</code></pre><h3 id="安装配置freeradius"><a href="#安装配置freeradius" class="headerlink" title="安装配置freeradius"></a>安装配置freeradius</h3><p>这里具体讲还需要安装配置哪些内容</p><pre><code>vim /etc/freeradius/radiusd.conf将$INCLUDE clients.conf注释掉INSERT INTO radcheck (username, attribute, op, value) VALUES (&#39;leo&#39;, &#39;CHAP-Password&#39;, &#39;:=&#39;, &#39;7A21990FCD3D759941E45C490F143D5F&#39;); 注意，这里的CHAP-Password与之前的clear-password不同，原因是l2tp验证时传来的信息中没有cleartext-password,所以mysql表中应该存储CHAP-Password，它是12345的加密结果</code></pre><h3 id="安装RreeRadius-Client服务"><a href="#安装RreeRadius-Client服务" class="headerlink" title="安装RreeRadius Client服务"></a>安装RreeRadius Client服务</h3><p>1 安装freeradius包</p><pre><code>  cd ~   wget -c ftp://ftp.freeradius.org/pub/freeradius/freeradius-client-1.1.7.tar.gz    tar -zxvf freeradius-client-1.1.7.tar.gz   cd freeradius-client-1.1.7   ./configure   make &amp;&amp; make install</code></pre><p>2 修改radiusclient.conf配置</p><p><code>vim /usr/local/etc/radiusclient/radiusclient.conf</code><br>注释掉radius_deadtime、bindaddr属性  </p><p><code>vim /usr/local/etc/radiusclient/radiusclient.conf</code>  </p><pre><code> #指定freeRadius服务器的IP，将SERVER_IP改为你的服务器IP地址： authserver      SERVER_IP acctserver      SERVER_IP #指定连接到服务器的配置文件目录： servers         /usr/local/etc/radiusclient/servers</code></pre><p>3 修改/usr/local/etc/radiusclient/dictionary配置<br><code>sed -i &#39;/ipv6/s/^/#/&#39; /usr/local/etc/radiusclient/dictionary</code><br>4 修改/usr/local/etc/radiusclient/servers配置<br><code>vim /usr/local/etc/radiusclient/servers</code></p><pre><code>xxx.xxx.xxx.xxx    testing123 #对应公网IP和密钥，之前FreeRadius已配置成testing123</code></pre><p>如果vpn和freeradius在同一台机器，可以默认localhost不变</p><p>5 修改/usr/local/etc/radiusclient/dictionary配置<br><code>vim /usr/local/etc/radiusclient/dictionary</code></p><pre><code>INCLUDE /usr/local/etc/radiusclient/dictionary.sipINCLUDE /usr/local/etc/radiusclient/dictionary.ascendINCLUDE /usr/local/etc/radiusclient/dictionary.meritINCLUDE /usr/local/etc/radiusclient/dictionary.compatINCLUDE /usr/local/etc/radiusclient/dictionary.microsoft</code></pre><p>###将FreeRadius与L2TP整合</p><p><code>/etc/ppp/options.xl2tpd增加内容</code></p><pre><code>plugin /usr/lib/pppd/2.4.5/radius.soradius-config-file /usr/local/etc/radiusclient/radiusclient.conf</code></pre><p>###修改vpn配置</p><p>/etc/xl2tpd/xl2tpd.conf</p><pre><code>[global]port = 1701[lns default]ip range = 192.168.42.10-192.168.42.250local ip = 192.168.42.1refuse chap = yesrefuse pap = yesrequire authentication = yesname = l2tpdpppoptfile = /etc/ppp/options.xl2tpdlength bit = yes</code></pre><p>######重启xl2tpd</p><p>/etc/init.d/xl2tpd restart</p><p>######启动FreeRadius</p><p>/etc/init.d/freeradius start</p><blockquote><p>1.<a href="https://blog.csdn.net/u013162322/article/details/80720712" target="_blank" rel="noopener">https://blog.csdn.net/u013162322/article/details/80720712</a><br>2.<a href="https://blog.csdn.net/u013162322/article/details/80725246" target="_blank" rel="noopener">https://blog.csdn.net/u013162322/article/details/80725246</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>freeradius wifi mysql认证</title>
    <link href="undefined2014/11/01/freeradius_wifi_mysql/"/>
    <url>2014/11/01/freeradius_wifi_mysql/</url>
    
    <content type="html"><![CDATA[<h3 id="radius协议："><a href="#radius协议：" class="headerlink" title="radius协议："></a>radius协议：</h3><blockquote><p>RADIUS：Remote Authentication Dial In User Service，远程用户拨号认证系统由RFC2865，RFC2866定义，是目前应用最广泛的AAA协议。AAA是一种管理框架，因此，它可以用多种协议来实现。在实践中，人们最常使用远程访问拨号用户服务（Remote Authentication Dial In User Service，RADIUS）来实现AAA。</p></blockquote><p>这里通过部署freeradius，backend为mysql，存储数据，来实现用户认证登录wifi。</p><h3 id="安装配置freeradius"><a href="#安装配置freeradius" class="headerlink" title="安装配置freeradius"></a>安装配置freeradius</h3><ol><li><p><code>sudo apt-get update</code></p></li><li><p><code>sudo apt-get install freeradius freeradius-mysql</code><br>使用mysql作为backend，需要安装freeradius-mysql模块</p></li><li><p><code>sudo vim /etc/freeradius/sites-enabled/default</code><br>编辑default文件，注释掉files的相关行，取消注释sql的所有行，不要删除默认配置的任何行。  </p></li><li><p><code>sudo vim /etc/freeradius/sites-enabled/inner-tunnel</code><br>取消注释sql的所有行，不要删除默认配置的任何行。</p></li><li><p><code>sudo vim /etc/freeradius/radiusd.conf</code><br>编辑radius.conf，取消注释$INCLUDE sql.conf</p></li><li><p><code>sudo vim /etc/freeradius/sql.conf</code>  </p><pre><code>sql { database = &quot;mysql&quot; server = &quot;localhost&quot; login = &quot;radius&quot; password = &quot;radpass&quot; radius_db = &quot;radius&quot; #uncomment read_groups read_groups = yes #uncomment readclients readclients = yes}</code></pre><h3 id="安装配置mysql"><a href="#安装配置mysql" class="headerlink" title="安装配置mysql"></a>安装配置mysql</h3></li><li><p><code>sudo apt-get install mysql-server</code><br>输入并重复新mysql root用户的密码</p></li><li><p><code>CREATE DATABASE radius;</code><br>创建radius的database </p></li><li><p><code>CREATE USER &#39;radius&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;radpass&#39;;</code><br>创建本地radius用户，密码</p></li><li><p><code>GRANT ALL PRIVILEGES ON *.* TO &#39;radius&#39;@&#39;localhost&#39;;</code><br>授权用户</p></li><li><p><code>FLUSH PRIVILEGES;</code></p></li><li><p><code>mysql -u root -p radius &lt; /etc/freeradius/sql/mysql/schema.sql;</code></p></li><li><p><code>mysql -u root -p radius &lt; /etc/freeradius/sql/mysql/nas.sql;</code><br>导入freeradius的sql文件</p></li><li><p><code>INSERT INTO nas VALUES (NULL , &#39;0.0.0.0/0, &#39;myNAS&#39;, &#39;other&#39;, NULL , &#39;testing123&#39;, NULL , NULL , &#39;RADIUS Client&#39;);</code></p></li><li><p><code>INSERT INTO radcheck (username, attribute, op, value) VALUES (&#39;thisuser&#39;, &#39;Cleartext-Password&#39;, &#39;:=&#39;, &#39;thispassword&#39;);</code></p></li><li><p><code>INSERT INTO radusergroup (username, groupname, priority) VALUES (&#39;thisuser&#39;, &#39;thisgroup&#39;, &#39;1&#39;);</code></p></li><li><p><code>INSERT INTO radgroupreply (groupname, attribute, op, value) VALUES (&#39;thisgroup&#39;, &#39;Service-Type&#39;, &#39;:=&#39;, &#39;Framed-User&#39;), (&#39;thisgroup&#39;, &#39;Framed-Protocol&#39;, &#39;:=&#39;, &#39;PPP&#39;), (&#39;thisgroup&#39;, &#39;Framed-Compression&#39;, &#39;:=&#39;, &#39;Van-Jacobsen-TCP-IP&#39;);</code><br>添加radius数据库中的数据</p></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>clear-text password 测试<br>1.<code>radtest thisuser thispassword 127.0.0.1 1 testing123</code></p><pre><code>ubuntu@ip-192-168-0-57:/etc/freeradius$ radtest thisuser thispassword 127.0.0.1 1 testing123Sent Access-Request Id 58 from 0.0.0.0:56965 to 127.0.0.1:1812 length 78    User-Name = &quot;thisuser&quot;    User-Password = &quot;thispassword&quot;    NAS-IP-Address = 192.168.0.57    NAS-Port = 1    Message-Authenticator = 0x00    Cleartext-Password = &quot;thispassword&quot;Received Access-Accept Id 58 from 127.0.0.1:1812 to 127.0.0.1:56965 length 38    Service-Type = Framed-User    Framed-Protocol = PPP    Framed-Compression = Van-Jacobson-TCP-IP</code></pre><p>测试通过后，可以使用测试路由器上配置实验了</p><blockquote><p>友情链接<br>1.<a href="https://www.vpsserver.com/community/tutorials/10/setup-and-configuration-of-freeradius-mysql-on-ubuntu-14-04-64bit/" target="_blank" rel="noopener">https://www.vpsserver.com/community/tutorials/10/setup-and-configuration-of-freeradius-mysql-on-ubuntu-14-04-64bit/</a><br>2.<a href="https://wiki.freeradius.org/guide/SQL-HOWTO-for-freeradius-3.x-on-Debian-Ubuntu" target="_blank" rel="noopener">https://wiki.freeradius.org/guide/SQL-HOWTO-for-freeradius-3.x-on-Debian-Ubuntu</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vpn 搭建流程</title>
    <link href="undefined2014/08/01/vpn/"/>
    <url>2014/08/01/vpn/</url>
    
    <content type="html"><![CDATA[<h4 id="搭建L2TP-IPsec-VPN-过程"><a href="#搭建L2TP-IPsec-VPN-过程" class="headerlink" title="搭建L2TP/IPsec VPN 过程"></a>搭建L2TP/IPsec VPN 过程</h4><h3 id="安装部署ipsec"><a href="#安装部署ipsec" class="headerlink" title="安装部署ipsec"></a>安装部署ipsec</h3><pre><code>apt-get install openswan</code></pre><p>安装openswan也就是安装ipsec。但是如果你深入去了解，就知道openswan是一套方案</p><h3 id="配置ipsec"><a href="#配置ipsec" class="headerlink" title="配置ipsec"></a>配置ipsec</h3><pre><code>1.sudo vim /etc/ipsec.conf添加如下配置即可，需注意left=yourip，这里的ip一般填写本机对应的公网ip，但是针对aws ec2或者aliyun的虚拟机时，需要填写虚拟机的私有ip，即使用ifconfig查看到的那个ip</code></pre><pre><code>version    2.0    config setup    dumpdir=/var/run/pluto/        nat_traversal=yes    virtual_private=%v4:10.0.0.0/8,%v4:192.168.0.0/16,%v4:172.16.0.0/12,%v4:25.0.0.0/8,%v6:fd00::/8,%v6:fe80::/10    oe=off    protostack=netkeyconn L2TP-PSK-NAT    rightsubnet=vhost:%priv    also=L2TP-PSK-noNATconn L2TP-PSK-noNAT    authby=secret    pfs=no    auto=add    keyingtries=3    rekey=no    ikelifetime=8h    keylife=1h    type=transport    left=192.168.0.57    leftprotoport=17/%any    right=%any    rightprotoport=17/%any</code></pre><pre><code>2.sudo vim /etc/ipsec.secrets这里是设置psk的地方，即客户端登陆时需要使用的密码。XXX.XXX.XXX.XXX一般也是本机对应的公网ip,但是针对aws ec2或者aliyun的虚拟机时，需要填写虚拟机的私有ip，即使用ifconfig查看到的那个ip</code></pre><pre><code>192.168.0.57 %any: PSK &quot;your password&quot;</code></pre><h3 id="运行ipsec"><a href="#运行ipsec" class="headerlink" title="运行ipsec"></a>运行ipsec</h3><pre><code>    sudo ipsec setup restart    sudo ipsec verify</code></pre><h3 id="安装部署ppp"><a href="#安装部署ppp" class="headerlink" title="安装部署ppp"></a>安装部署ppp</h3><pre><code>sudo apt-get install ppp</code></pre><h3 id="配置ppp"><a href="#配置ppp" class="headerlink" title="配置ppp"></a>配置ppp</h3><pre><code>1.sudo vim /etc/ppp/chap-secrets有两个星号，第一个表示以后所有使用PPP作为用户认证的服务，都可以使用这个用户名和密码，包括PPTP和L2TP都可以使用loginname。第二个星号表示这个用户可以从任何IP登录。如果你希望控制一下，可以把星号改成具体的值来限制。</code></pre><pre><code>loginname *  loginpassword  *</code></pre><h3 id="安装部署xl2tpd"><a href="#安装部署xl2tpd" class="headerlink" title="安装部署xl2tpd"></a>安装部署xl2tpd</h3><pre><code>sudo apt-get install xl2tpd</code></pre><h3 id="配置xl2tpd"><a href="#配置xl2tpd" class="headerlink" title="配置xl2tpd"></a>配置xl2tpd</h3><pre><code>1.sudo vim /etc/xl2tpd/xl2tpd.conf同样listen-addr里边需要填写对于Linux来说的“外网”ip，在亚马逊EC2系统是私有ip。可以从amazon的控制台查看，或者ifconfig查看。</code></pre><pre><code>[global]ipsec saref = yeslisten-addr = 192.168.0.57[lns default]ip range = 192.168.1.2-192.168.1.100local ip = 192.168.1.1refuse chap = yesrefuse pap = yesrequire authentication = yesppp debug = yespppoptfile = /etc/ppp/options.xl2tpdlength bit = yes</code></pre><pre><code>2.sudo vim /etc/ppp/options.xl2tpd</code></pre><pre><code>require-mschap-v2ms-dns 8.8.8.8ms-dns 8.8.4.4asyncmap 0authcrtsctslockhide-passwordmodemdebugname l2tpdproxyarplcp-echo-interval 30lcp-echo-failure 4</code></pre><h3 id="运行xl2tpd"><a href="#运行xl2tpd" class="headerlink" title="运行xl2tpd"></a>运行xl2tpd</h3><pre><code>service xl2tpd restart</code></pre><h3 id="配置sysctl"><a href="#配置sysctl" class="headerlink" title="配置sysctl"></a>配置sysctl</h3><pre><code>1.sudo vim /etc/sysctl.conf添加一下内容```</code></pre><p>net.ipv4.ip_forward = 1<br>net.ipv4.conf.default.rp_filter = 0<br>net.ipv4.conf.default.accept_source_route = 0<br>net.ipv4.conf.all.send_redirects = 0<br>net.ipv4.conf.default.send_redirects = 0<br>net.ipv4.conf.all.log_martians = 0<br>net.ipv4.conf.default.log_martians = 0<br>net.ipv4.conf.all.accept_redirects = 0<br>net.ipv4.conf.default.accept_redirects = 0<br>net.ipv4.icmp_ignore_bogus_error_responses = 1<br>    ```<br>    2.sudo sysctl -p<br>    使修改生效</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><pre><code>    sudo ipsec setup restart    tail -f /var/log/auth.log 查看日志</code></pre><p>最后还有一点，在amazon安全组对用到的端口放行，以使得客户端可以通过防火墙链接到虚拟机。现在实例中找到对应属于的安全组，然后再在安全组添加入站规则如下，其中来源选择任何位置</p><p>UDP port 1701 (for L2TP)<br>UDP port 500 (for IKE)<br>UDP port 4500 (for IPSec over UDP)</p><p>搭建工作完成了，如果按照我的流程一步一步来到话，相信你也会成功的，我自己就是按照这个流程一步一步在amazon linux搭建好的。</p><p>这里用到的软件分别起这些作用：</p><p>openswan(ipsec) : 提供一个密钥<br>ppp ：提供用户名和密码<br>xl2tpd ： 提供L2TP服务<br>sysctl ： 提供服务器内部转发<br>iptables ： 提供请求从服务器内部转向外部，外部响应转向服务器内部</p><p>报错：</p><pre><code>ERROR: netlink XFRM_MSG_DELPOLICY response for flow eroute_connection delete included errno 2: No such file or directory……deleting connection &quot;L2TP-PSK-NAT&quot;</code></pre><p>解决方法：</p><ol><li><p>修改 /etc/ipsec.conf ：修改 leftprotoport from 17/1701 to 17/%any</p></li><li><p>重启 ipsec 服务：/etc/init.d/ipsec restart</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>